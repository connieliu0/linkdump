const U = (t) => ({ current: t }), pt = {
  EFFECT: "effect",
  REF: "ref",
  STATE: "state"
};
let Ft = null;
const dt = [], pe = () => dt[dt.length - 1], ge = (t, e) => {
  dt.push(t), Ft = e;
}, ve = () => dt.pop(), Ee = () => Ft, H = {
  get: pe,
  getInitializationId: Ee,
  push: ge,
  pop: ve
}, ye = (t, e, n) => {
  const o = {
    batchTimeoutRender: null,
    it: 0,
    hooks: [],
    render: () => {
      o.unmounted || (H.push(o, t), o.it = 0, e(o.props), H.pop());
    },
    props: {},
    unmounted: !1
  }, r = () => {
    o.unmounted || (o.unmounted = !0, o.hooks.forEach((i) => {
      i.type === pt.EFFECT && i.onUnmount && i.onUnmount();
    }));
  }, s = (i) => {
    const l = n ? n(i) : i;
    let c = !1;
    return Object.entries(l).forEach(([u, a]) => {
      if (a === void 0)
        return;
      const f = o.props[u];
      f && typeof f == "object" && "current" in f ? f.current = a : (o.props[u] = a, c = !0);
    }), c;
  };
  return {
    context: o,
    render: o.render,
    unmount: r,
    updateProps: s
  };
}, xe = (t = 0) => (e, n) => ye(t, e, n), Ce = (t) => {
  t.forEach((e) => {
    e.render();
  });
}, be = (t, e) => {
  for (let n = 0; n < t.length; n++)
    if (t[n] !== e[n])
      return !1;
  return !0;
}, E = (t, e) => {
  const n = H.get(), o = n.it;
  n.it++;
  let r = n.hooks[o];
  if (!r) {
    const i = t();
    r = { type: pt.EFFECT, deps: e, onUnmount: i }, n.hooks[o] = r;
    return;
  }
  if (be(r.deps, e))
    return;
  r.onUnmount && r.onUnmount();
  const s = t();
  r.onUnmount = s, r.deps = e;
}, wt = {}, St = (t, e) => {
  E(() => {
    const n = `${H.getInitializationId()}.${t}`;
    return wt[n] = e, () => {
      delete wt[n];
    };
  }, [e]);
}, Pt = (t) => wt[`${H.getInitializationId()}.${t}`], I = (t) => {
  const e = H.get(), n = e.it;
  e.it++;
  let o = e.hooks[n];
  if (!o) {
    const r = { current: t || null };
    return o = { type: pt.REF, value: r }, e.hooks[n] = o, r;
  }
  return o.value;
}, mt = (t) => {
  const e = H.get(), n = e.it;
  e.it++;
  let o = e.hooks[n];
  const r = (s) => {
    o.value = s, clearTimeout(e.batchTimeoutRender), e.batchTimeoutRender = setTimeout(e.render, 0);
  };
  return o ? [o.value, r] : (o = { type: pt.STATE, value: t }, e.hooks[n] = o, [t, r]);
}, jt = "elements", W = () => Pt(jt), Me = () => {
  const t = I({}), e = I(null), n = I({}), o = I();
  St(jt, {
    elementsRef: t,
    elementsInMoveRef: e,
    elementsUpdatePositionApiRef: n,
    lastElementMouseMoveEventRef: o
  });
}, j = 30, Te = "panzoom-core", we = "panzoom-core-element", Re = 20, lt = 15, Se = 15, Pe = 15, Oe = 250, ze = 20, Le = 30, _e = 0.125, Ie = 0.04, Ae = 0.3, De = 5, Ne = 1, Ut = 1e4, Ze = 20, Yt = 1, Ue = 5, Ye = 300, $e = {
  width: "100%",
  height: "100%",
  overflow: "hidden",
  "touch-action": "none",
  "-webkit-font-smoothing": "antialiased"
}, Be = {
  position: "relative",
  overflow: "hidden",
  "transform-origin": "0 0",
  "pointer-events": "none"
}, Xe = {
  "user-select": "none"
}, ke = {
  display: "inline-block",
  position: "absolute",
  left: "0px",
  top: "0px",
  "pointer-events": "all"
}, He = {
  position: "absolute",
  width: "100%",
  height: "100%",
  left: "0px",
  top: "0px",
  "z-index": "2147483647"
}, $t = {
  "background-color": "#ccc",
  opacity: "0.5"
}, We = (t, e) => {
  var n, o;
  document.body.classList.add(e), (o = (n = t == null ? void 0 : t.parentNode) == null ? void 0 : n.classList) == null || o.add(`${e}-in`);
}, Ve = (t, e) => {
  var n, o;
  document.body.classList.remove(e), document.body.getAttribute("class") || document.body.removeAttribute("class"), (o = (n = t == null ? void 0 : t.parentNode) == null ? void 0 : n.classList) == null || o.remove(`${e}-in`);
}, X = {
  add: We,
  remove: Ve
}, V = () => window, Kt = (t) => "touches" in t ? t.touches.length > 1 : !1, K = (t, e, n) => (e.forEach((o) => {
  t.addEventListener(o, n);
}), () => {
  e.forEach((o) => {
    t.removeEventListener(o, n);
  });
}), et = (t, e) => K(t, ["mousedown", "touchstart"], e), nt = (t, e) => {
  const n = K(V(), ["mouseup"], e), o = K(t, ["touchend", "touchcancel"], e);
  return () => {
    n(), o();
  };
}, G = (t) => {
  const e = K(V(), ["mousemove"], t), n = (r) => {
    Kt(r) || t(r);
  }, o = K(V(), ["touchmove"], n);
  return () => {
    e(), o();
  };
}, Gt = (t, e) => K(t, ["contextmenu"], e), Y = (t) => {
  const { touches: e } = t;
  if (e)
    return {
      clientX: e[0].clientX,
      clientY: e[0].clientY
    };
  const n = t;
  return {
    clientX: n.clientX,
    clientY: n.clientY
  };
}, A = ({ position: t, zoom: e }) => e ? `translate(${t.x}px, ${t.y}px) scale(${e})` : `translate(${t.x}px, ${t.y}px)`, qt = () => {
  const t = () => {
    t.done = !0;
  };
  return t.done = !1, t;
}, Ot = ({
  elementsRef: t,
  elementsInMove: e,
  onElementsChange: n,
  produceNextPosition: o
}) => {
  const r = {}, s = () => {
    let c = null;
    const u = (a, f) => {
      c !== null && Math.abs(a - f) >= Math.abs(c) || (c = a - f, u.value = c);
    };
    return u.value = c, u;
  }, i = s(), l = s();
  Object.entries(e).forEach(([c, u]) => {
    const a = t.current[c], f = o(u, a);
    i(a.position.x, f.x), l(a.position.y, f.y);
  }), Object.entries(e).forEach(([c]) => {
    const u = t.current[c], a = {
      x: u.position.x - i.value,
      y: u.position.y - l.value
    };
    r[c] = a, u.position = a, u.node.current.style.transform = A({ position: a });
  }), n && n(r);
}, v = (t) => t.getBoundingClientRect(), gt = (t) => {
  const e = (n, o) => {
    for (let r = t; r && !(!r || o && o(r)); r = r.parentNode)
      n(r);
  };
  return {
    forEachToWindow: (n) => {
      e(n);
    },
    forEach: (n) => {
      e(n, (o) => o === document.body);
    }
  };
}, vt = (t) => {
  const e = t.parentNode, n = {
    x: 0,
    y: 0
  };
  return gt(e.parentNode).forEachToWindow((o) => {
    n.x += o.scrollLeft || 0, n.y += o.scrollTop || 0;
  }), n;
}, q = ({
  elementNode: t,
  childNode: e,
  x: n,
  y: o,
  zoom: r
}) => {
  const s = v(t), i = v(e), l = (i.width - s.width) / r, c = (i.height - s.height) / r, u = { x: n, y: o };
  return u.x < 0 ? u.x = 0 : u.x > l && (u.x = l), u.y < 0 ? u.y = 0 : u.y > c && (u.y = c), u;
}, Jt = "panzoom", _ = () => Pt(Jt), Fe = (t) => {
  St(Jt, t);
}, je = (t, e) => {
  const n = t.parentNode;
  return {
    apiRef: U(null),
    blockMovingRef: U(!1),
    boundary: e.boundary,
    childNode: t,
    className: e.className || "panzoom-core",
    containerNode: n,
    disabled: e.disabled || !1,
    disabledElements: e.disabledElements || !1,
    disabledScrollHorizontal: e.disabledScrollHorizontal === void 0 ? !0 : e.disabledScrollHorizontal,
    disabledScrollVertical: e.disabledScrollVertical === void 0 ? !0 : e.disabledScrollVertical,
    disabledUserSelect: e.disabledUserSelect || !1,
    disabledZoom: e.disabledZoom || !1,
    disabledMove: e.disabledMove || !1,
    elementsAutoMoveAtEdge: e.elementsAutoMoveAtEdge === void 0 ? !0 : e.elementsAutoMoveAtEdge,
    onContextMenuRef: U(e.onContextMenu),
    onContainerChangeRef: U(e.onContainerChange),
    onContainerClickRef: U(e.onContainerClick),
    onContainerPositionChangeRef: U(e.onContainerPositionChange),
    onContainerZoomChangeRef: U(e.onContainerZoomChange),
    onElementsChangeRef: U(e.onElementsChange),
    positionRef: U({ x: 0, y: 0 }),
    selecting: e.selecting || !1,
    scrollSpeed: e.scrollSpeed || Le,
    width: e.width || "100%",
    height: e.height || "100%",
    zoomRef: U(e.zoomInitial || Yt),
    zoomInitial: e.zoomInitial || Yt,
    zoomMin: e.zoomMin || Ae,
    zoomMax: e.zoomMax || De,
    zoomPosition: e.zoomPosition,
    zoomSpeed: e.zoomSpeed || Ne
  };
}, Ke = () => [
  "boundary",
  "className",
  "disabled",
  "disabledElements",
  "disabledMove",
  "disabledScrollHorizontal",
  "disabledScrollVertical",
  "disabledUserSelect",
  "disabledZoom",
  "elementsAutoMoveAtEdge",
  "onElementsChange",
  "onContextMenu",
  "onContainerChange",
  "onContainerClick",
  "onContainerPositionChange",
  "onContainerZoomChange",
  "selecting",
  "scrollSpeed",
  "width",
  "height",
  "zoomInitial",
  "zoomMax",
  "zoomMin",
  "zoomPosition",
  "zoomSpeed"
], Ge = (t) => {
  const e = {}, n = Ke();
  return Object.entries(t).forEach(([o, r]) => {
    !n.includes(o) || r === void 0 || (typeof r == "function" ? e[`${o}Ref`] = r : e[o] = r);
  }), e;
}, Qt = () => {
  const { childNode: t, containerNode: e, zoomRef: n } = _();
  return (o, r) => {
    const s = Y(o), i = v(e), l = v(r), c = vt(t);
    return {
      x: (s.clientX - l.left + i.left + c.x) / n.current,
      y: (s.clientY - l.top + i.top + c.y) / n.current
    };
  };
}, te = () => {
  const { childNode: t, positionRef: e, zoomRef: n } = _();
  return (o, r, s) => {
    const i = Y(o), l = vt(t);
    return q({
      elementNode: s,
      childNode: t,
      x: (i.clientX - e.current.x + l.x) / n.current - r.x,
      y: (i.clientY - e.current.y + l.y) / n.current - r.y,
      zoom: n.current
    });
  };
}, B = (t, e) => {
  const n = e.trim().split(" ").filter((o) => o);
  return n.forEach((o) => {
    t.classList.add(o);
  }), () => {
    n.forEach((o) => {
      t.classList.remove(o);
    }), t.className || t.removeAttribute("class");
  };
}, ee = (t) => {
  t.getAttribute("style") || t.removeAttribute("style");
}, k = (t, e) => (Object.entries(e).forEach(([n, o]) => {
  t.style.setProperty(n, o);
}), () => {
  Object.entries(e).forEach(([n]) => {
    t.style.removeProperty(n);
  }), ee(t);
});
let Bt = 2;
const ne = (t) => {
  Bt += 1, t.style.zIndex = Bt.toString();
}, zt = () => {
  const t = v(document.body), e = V();
  return !t.width || !t.height ? {
    width: e.innerWidth,
    height: e.innerHeight
  } : {
    width: Math.min(t.width, e.innerWidth),
    height: Math.min(t.height, e.innerHeight)
  };
}, Et = (t) => {
  const e = v(t.parentNode), n = zt(), o = [
    n.width - (e.left < 0 ? 0 : e.left),
    e.right
  ], r = [
    n.height - (e.top < 0 ? 0 : e.top),
    e.bottom
  ];
  gt(t.parentNode).forEach((l) => {
    if (!l.getBoundingClientRect)
      return;
    const c = v(l);
    c.right > 0 && o.push(c.right - c.left), c.bottom > 0 && r.push(c.bottom - c.top);
  });
  let s = Math.min(...o), i = Math.min(...r);
  return s < 0 && (s = 0), i < 0 && (i = 0), [s, i];
}, oe = (t) => {
  const [e] = Et(t), n = v(t), o = v(t.parentNode), r = Math.max(o.left, 0);
  return n.right - e - r;
}, qe = (t, e) => {
  const n = v(t), o = v(t.parentNode), r = e.current.x + n.width;
  return r + o.left > 0 && r >= 0 && oe(t) <= 0;
}, re = (t) => {
  const [, e] = Et(t), n = v(t), o = v(t.parentNode), r = Math.max(o.top, 0);
  return n.bottom - e - r;
}, Je = (t, e) => {
  const n = v(t), o = v(t.parentNode), r = e.current.y + n.height;
  return r + o.top > 0 && r >= 0 && re(t) <= 0;
}, Qe = (t, e) => {
  const n = vt(t), o = v(t.parentNode), [r] = Et(t);
  return e.current.x + o.left >= 0 && e.current.x >= 0 && e.current.x < r + n.x;
}, tn = (t, e) => {
  const n = vt(t), o = v(t.parentNode), [, r] = Et(t);
  return e.current.y + o.top >= 0 && e.current.y >= 0 && e.current.y < r + n.y;
}, at = {
  left: Qe,
  right: qe,
  top: tn,
  bottom: Je
}, en = (t) => t.clientHeight < t.scrollHeight, se = (t) => "scrollX" in t && "scrollY" in t, Rt = (t) => {
  if (se(t)) {
    const n = t;
    return {
      x: n.scrollX || 0,
      y: n.scrollY || 0
    };
  }
  const e = t;
  return {
    x: e.scrollLeft || 0,
    y: e.scrollTop || 0
  };
}, Xt = (t, e) => {
  if (se(t))
    t.scrollBy(e.x, e.y);
  else {
    const n = t;
    n.scrollLeft += e.x, n.scrollTop += e.y;
  }
  return Rt(t);
}, nn = (t, e, n) => {
  const o = t.parentNode, r = v(o), s = zt(), i = e < 0 && r.right > 0 && s.width > r.right, l = e > 0 && r.left >= 0, c = i || l, u = n < 0 && r.bottom > 0 && s.height > r.bottom, a = n > 0 && r.top >= 0, f = u || a, m = {
    x: e,
    y: n
  };
  return c && f || gt(o.parentNode).forEachToWindow((d) => {
    if (en(d)) {
      if (!c) {
        let h = Rt(d);
        const p = h.x;
        h = Xt(d, { x: -m.x, y: 0 }), m.x += h.x - p;
      }
      if (!f) {
        let h = Rt(d);
        const p = h.y;
        h = Xt(d, { x: 0, y: -m.y }), m.y += h.y - p;
      }
    }
  }), m;
}, on = ({
  childNode: t,
  positionRef: e,
  addPosition: n,
  zoomRef: o
}) => {
  const r = nn(t, n.x, n.y);
  if (e.current = {
    x: e.current.x + r.x,
    y: e.current.y + r.y
  }, r.y < 0) {
    const s = re(t);
    s < -r.y && (e.current.y += -r.y - s);
  } else
    r.y > 0 && e.current.y > 0 && (e.current.y = 0);
  if (r.x < 0) {
    const s = oe(t);
    s < -r.x && (e.current.x += -r.x - s);
  } else
    r.x > 0 && e.current.x > 0 && (e.current.x = 0);
  t.style.transform = A({
    position: e.current,
    zoom: o.current
  });
}, rn = (t, e) => {
  const n = v(t), o = v(t.parentNode), r = o.left > 0 ? o.left : 0, s = o.top > 0 ? o.top : 0, i = zt();
  let l = n.left - r;
  l < 0 && (l = 0);
  let c = n.top - s;
  c < 0 && (c = 0);
  const u = [
    i.width - r,
    n.right,
    o.right - j,
    o.right - o.left
  ], a = [
    i.height - s,
    n.bottom,
    o.bottom - j,
    o.bottom - o.top
  ];
  gt(t.parentNode).forEach((g) => {
    if (!g.getBoundingClientRect)
      return;
    const y = v(g);
    y.right > 0 && u.push(y.right - r), y.bottom > 0 && a.push(y.bottom - s);
  });
  const f = Math.min(...u), m = Math.min(...a), d = e.clientX - r, h = e.clientY - s, p = {
    top: !1,
    bottom: !1,
    left: !1,
    right: !1
  };
  return l + j > d ? p.left = !0 : d + j > f && (p.right = !0), c + j > h ? p.top = !0 : h + j > m && (p.bottom = !0), p;
}, sn = () => {
  const {
    childNode: t,
    onElementsChangeRef: e,
    positionRef: n,
    zoomRef: o
  } = _(), { elementsRef: r, lastElementMouseMoveEventRef: s } = W();
  return (i) => {
    const l = setInterval(() => {
      if (!s.current || !t)
        return;
      const c = {
        x: 0,
        y: 0
      }, u = rn(t, s.current);
      u.left && !at.left(t, n) ? c.x = lt : u.right && !at.right(t, n) && (c.x = -lt), u.top && !at.top(t, n) ? c.y = lt : u.bottom && !at.bottom(t, n) && (c.y = -lt), !(!c.x && !c.y) && (on({
        childNode: t,
        positionRef: n,
        addPosition: c,
        zoomRef: o
      }), Ot({
        elementsRef: r,
        elementsInMove: i,
        produceNextPosition: (a, f) => q({
          elementNode: f.node.current,
          childNode: t,
          x: f.position.x - c.x / o.current,
          y: f.position.y - c.y / o.current,
          zoom: o.current
        }),
        onElementsChange: e.current
      }));
    }, Re);
    return () => {
      clearInterval(l), s.current = null;
    };
  };
}, ce = (t) => `${t}px`, ie = ({
  className: t,
  elementNode: e,
  cb: n,
  onAfterResize: o,
  resizerNode: r
}) => {
  et(r, (s) => {
    if (s.button)
      return;
    s.preventDefault(), s.stopPropagation();
    const i = B(e, `${t}--resizing`), l = n(s);
    let c = null;
    c = nt(r, () => {
      i(), l(), c(), o();
    }), ne(e);
  });
}, ue = () => {
  const t = document.createElement("div");
  return t.style.position = "absolute", t;
}, cn = ({
  childNode: t,
  className: e,
  elementNode: n,
  elementsRef: o,
  id: r,
  onAfterResize: s,
  onStartResizing: i,
  resizedMaxWidth: l,
  resizedMinWidth: c,
  resizerWidth: u,
  zoomRef: a
}) => {
  const f = ue();
  return f.style.left = "0px", f.style.top = "0px", f.style.width = ce(u), f.style.height = "100%", f.style.cursor = "w-resize", ie({
    className: e,
    elementNode: n,
    resizerNode: f,
    cb: (m) => {
      const d = Y(m), h = t.getBoundingClientRect(), p = V().getComputedStyle(n), g = new DOMMatrixReadOnly(p.transform), y = n.getBoundingClientRect();
      let x = (y.right - h.left) / a.current;
      return l && l < x && (x = l), i(), G((O) => {
        const M = Y(O), C = {
          x: M.clientX - d.clientX,
          y: M.clientY - d.clientY
        };
        let R = y.width / a.current - C.x / a.current;
        c && R < c && (C.x += (R - c) * a.current, R = c), R > x && (C.x += (R - x) * a.current, R = x), n.style.width = `${R}px`;
        const T = q({
          elementNode: n,
          childNode: t,
          x: g.e + C.x / a.current,
          y: g.f,
          zoom: a.current
        });
        c && R < c && (T.x = g.e + y.width / a.current - c), n.style.transform = A({ position: T }), o.current[r].position = T;
      });
    },
    onAfterResize: s
  }), n.appendChild(f), () => {
    n.removeChild(f);
  };
}, un = ({
  childNode: t,
  className: e,
  elementNode: n,
  elementsRef: o,
  id: r,
  onAfterResize: s,
  onStartResizing: i,
  resizedMaxWidth: l,
  resizedMinWidth: c,
  resizerWidth: u,
  zoomRef: a
}) => {
  const f = ue();
  return f.style.right = "0px", f.style.top = "0px", f.style.width = ce(u), f.style.height = "100%", f.style.cursor = "e-resize", ie({
    className: e,
    elementNode: n,
    resizerNode: f,
    cb: (m) => {
      const d = Y(m), h = n.getBoundingClientRect(), p = t.getBoundingClientRect();
      let g = (p.right - h.left) / a.current;
      return l && l < g && (g = l), i(), G((y) => {
        const x = Y(y), O = {
          x: x.clientX - d.clientX,
          y: x.clientY - d.clientY
        };
        let M = h.width / a.current + O.x / a.current;
        if (c && M < c) {
          n.style.width = `${c}px`;
          return;
        }
        M > g && (M = g), n.style.width = `${M}px`;
        const C = q({
          elementNode: n,
          childNode: t,
          x: (h.x - p.x) / a.current,
          y: (h.y - p.y) / a.current,
          zoom: a.current
        });
        n.style.transform = A({ position: C }), o.current[r].position = C;
      });
    },
    onAfterResize: s
  }), n.appendChild(f), () => {
    n.removeChild(f);
  };
}, ln = (t, e) => {
  const { childNode: n, className: o, zoomRef: r } = _(), { elementsRef: s } = W(), i = `${o}--element-resizing`, l = I();
  l.current = e.onAfterResize;
  const c = I();
  c.current = e.onStartResizing, E(() => {
    if (e.disabled || !e.resizable)
      return;
    const u = e.resizedMinWidth || Pe, a = e.resizerWidth || Se, f = () => {
      X.add(n, i), c.current && c.current({
        id: e.id
      });
    }, m = () => {
      X.remove(n, i), l.current && l.current({
        id: e.id
      });
    }, d = cn({
      childNode: n,
      elementNode: t,
      elementsRef: s,
      ...e,
      onAfterResize: m,
      onStartResizing: f,
      resizedMinWidth: u,
      resizerWidth: a,
      zoomRef: r
    }), h = un({
      childNode: n,
      elementNode: t,
      elementsRef: s,
      ...e,
      onAfterResize: m,
      onStartResizing: f,
      resizedMinWidth: u,
      resizerWidth: a,
      zoomRef: r
    });
    return () => {
      d(), h();
    };
  }, [
    i,
    e.className,
    e.disabled,
    e.resizable,
    e.resizedMaxWidth,
    e.resizedMinWidth,
    e.resizerWidth
  ]);
}, an = (t) => ({
  id: e,
  className: n = we,
  disabled: o,
  disabledMove: r,
  draggableSelector: s,
  followers: i = [],
  x: l = 0,
  y: c = 0,
  family: u,
  height: a,
  onAfterResize: f,
  onContextMenu: m,
  onStartResizing: d,
  onClick: h,
  onMouseUp: p,
  resizable: g,
  resizerWidth: y,
  resizedMaxWidth: x,
  resizedMinWidth: O,
  width: M
}) => {
  if (!e)
    throw new Error("'id' prop for element can't be undefined");
  const C = Qt(), R = te(), T = sn(), [w, N] = mt(null), { elementsInMoveRef: S } = W(), b = (z) => {
    N(z), S.current = z;
  };
  ln(t, {
    className: n,
    disabled: o,
    id: e,
    onAfterResize: f,
    onStartResizing: d,
    resizable: g,
    resizerWidth: y,
    resizedMaxWidth: x,
    resizedMinWidth: O
  });
  const {
    blockMovingRef: D,
    boundary: J,
    childNode: P,
    className: ot,
    disabledElements: Q,
    elementsAutoMoveAtEdge: Dt,
    onElementsChangeRef: Nt
  } = _(), rt = `${ot}--element-moving`, {
    elementsRef: F,
    elementsUpdatePositionApiRef: Zt,
    lastElementMouseMoveEventRef: he
  } = W(), xt = I();
  xt.current = h;
  const Ct = I();
  Ct.current = p;
  const bt = I();
  bt.current = m, E(() => (Zt.current[e] = b, () => {
    t.style.transform = null, t.style.zIndex = null, delete F.current[e], delete Zt.current[e];
  }), []), E(() => {
    const z = { x: l, y: c };
    t.style.transform = A({ position: z }), F.current[e] = {
      family: u,
      id: e,
      node: { current: t },
      position: z
    };
  }, [e, l, c]), E(() => {
    const z = F.current[e];
    z && (z.family = u);
  }, [u]), E(() => {
    if (o || Q)
      return;
    const z = (L) => s && !L.target.closest(s), st = (L) => {
      if (L.button || z(L))
        return;
      const tt = C(L, t), it = qt();
      if (xt.current && xt.current({
        id: e,
        family: u,
        e: L,
        stop: it,
        ...tt
      }), L.preventDefault(), L.stopPropagation(), it.done || r)
        return;
      const Z = Object.values(F.current).filter(
        ($) => $.id === e || u && $.family === u || i.includes($.id)
      );
      b(Z.reduce(($, ut) => ($[ut.id] = C(L, ut.node.current), $), {})), ne(t);
    }, ct = (L) => {
      if (!bt.current || z(L))
        return;
      const tt = C(L, t);
      bt.current({
        id: e,
        family: u,
        e: L,
        ...tt
      });
    }, Mt = et(t, st), Tt = Gt(t, ct);
    return () => {
      Mt(), Tt();
    };
  }, [
    o,
    Q,
    r,
    s,
    u,
    JSON.stringify(i),
    JSON.stringify(J),
    e,
    rt
  ]), E(() => {
    if (!w)
      return;
    X.add(P, rt);
    let z = null;
    Dt && (z = T(w));
    let st = {};
    const ct = (Z) => {
      st = Z, Nt.current && Nt.current(Z);
    }, Mt = (Z) => {
      if (D.current || Z.buttons === 0) {
        b(null);
        return;
      }
      he.current = Y(Z), Ot({
        elementsRef: F,
        elementsInMove: w,
        produceNextPosition: ($, ut) => R(Z, $, ut.node.current),
        onElementsChange: ct
      });
    }, Tt = (Z) => {
      Ct.current && Ct.current({
        id: e,
        family: u,
        e: Z,
        ...F.current[e].position
      }), b(null), X.remove(P, rt);
    }, L = setInterval(() => {
      ct(st);
    }, Oe), tt = nt(t, Tt), it = G(Mt);
    return () => {
      z && z(), tt(), it(), clearInterval(L), X.remove(P, rt);
    };
  }, [Dt, w]), E(
    () => k(t, ke),
    []
  ), E(
    () => B(t, `${n} ${n}--id-${e}`),
    [n, e]
  ), E(() => {
    if (o)
      return B(t, `${n}--disabled`);
  }, [n, o]), E(() => {
    t.style.width = M === void 0 ? null : `${M}px`;
  }, [M]), E(() => {
    t.style.height = a === void 0 ? null : `${a}px`;
  }, [a]);
}, fn = (t) => {
  const e = [];
  return {
    add: (r, s) => {
      const i = an(r), l = t(i);
      return l.updateProps(s), e.push(l), l.render(), {
        destroy: () => {
          l.unmount();
          const a = e.findIndex((f) => f === l);
          a < 0 || e.splice(a, 1);
        },
        setOptions: (a) => {
          l.updateProps(a), l.render();
        }
      };
    },
    queue: e,
    unmount: () => {
      e.forEach((r) => {
        r.unmount();
      });
    }
  };
}, ht = (t) => typeof t == "number" ? `${t}px` : t, le = () => {
  const { containerNode: t, positionRef: e } = _();
  return (n) => {
    const o = Y(n), r = v(t);
    return {
      x: o.clientX - r.left - (e.current.x || 0),
      y: o.clientY - r.top - (e.current.y || 0)
    };
  };
}, ae = "select", Lt = () => Pt(ae), dn = () => {
  const [t, e] = mt(null), {
    boundary: n,
    setBoundary: o,
    selectRef: r,
    expandingRef: s
  } = Lt(), i = I(), { childNode: l, selecting: c, zoomRef: u } = _(), a = le(), f = (m, d) => {
    const h = v(l), p = a(m);
    p.x < 0 ? p.x = 0 : p.x > h.width && (p.x = h.width), p.y < 0 ? p.y = 0 : p.y > h.height && (p.y = h.height);
    const g = {
      width: (p.x - d.x) / u.current,
      height: (p.y - d.y) / u.current,
      left: d.x / u.current,
      top: d.y / u.current
    };
    g.width < 0 && (g.width = -g.width, g.left -= g.width), g.height < 0 && (g.height = -g.height, g.top -= g.height), g.right = g.left + g.width, g.bottom = g.top + g.height, s.current.style.transform = `translate(${g.left}px, ${g.top}px)`, s.current.style.width = `${g.width}px`, s.current.style.height = `${g.height}px`, i.current = g;
  };
  return E(() => {
    if (t || n || !c)
      return;
    const m = (d) => {
      d.preventDefault(), d.stopPropagation();
      const h = a(d);
      e(h), f(d, h);
    };
    return r.current.addEventListener("mousedown", m), () => {
      r.current.removeEventListener("mousedown", m);
    };
  }, [n, t, c]), E(() => {
    if (!t || n)
      return;
    const m = (g) => {
      f(g, t), e(null), o(i.current);
    }, h = G((g) => f(g, t)), p = nt(V(), m);
    return () => {
      h(), p();
    };
  }, [n, t]), { expanding: t, boundary: n };
}, ft = (t) => typeof t == "string" ? parseInt(t, 10) : t, mn = (t, e) => {
  const n = {};
  return Object.entries(e).forEach(([o, r]) => {
    r.position.x >= ft(t.left) && r.position.x <= ft(t.right) && r.position.y >= ft(t.top) && r.position.y <= ft(t.bottom) && (n[o] = r);
  }), n;
}, hn = (t) => {
  const e = {};
  return Object.entries(t).forEach(([n, o]) => {
    e[n] = { ...o.position };
  }), e;
}, pn = () => {
  const { boundary: t } = Lt(), { childNode: e, onElementsChangeRef: n, zoomRef: o } = _(), { elementsRef: r } = W(), s = I();
  return E(() => {
    if (!t)
      return;
    const i = mn(t, r.current), l = hn(i);
    let c = null;
    return s.current = (u) => {
      c || (c = u);
      const a = {};
      Object.entries(i).forEach(([f, m]) => {
        const d = l[f], { node: h } = m, p = q({
          elementNode: m.node.current,
          childNode: e,
          x: d.x + (u.x - c.x),
          y: d.y + (u.y - c.y),
          zoom: o.current
        });
        r.current[m.id].position = p, a[f] = p, h.current.style.transform = `translate(${p.x}px, ${p.y}px)`;
      }), n.current && n.current(a);
    }, () => {
      s.current = null;
    };
  }, [t]), s;
}, gn = () => {
  const t = pn(), {
    boundary: e,
    setBoundary: n,
    movingRef: o,
    selectRef: r,
    move: s,
    setMove: i
  } = Lt(), l = Qt(), c = te();
  E(() => {
    if (!e)
      return;
    const u = (d) => {
      d.preventDefault(), d.stopPropagation(), n(null);
    }, a = (d) => {
      d.preventDefault(), d.stopPropagation();
      const h = l(d, r.current), p = {
        x: h.x - e.left,
        y: h.y - e.top
      };
      i(p);
    }, f = et(r.current, u), m = et(o.current, a);
    return () => {
      f(), m();
    };
  }, [e]), E(() => {
    if (!s)
      return;
    const u = (d) => {
      d.preventDefault(), d.stopPropagation();
      const h = c(d, s, o.current);
      o.current.style.transform = `translate(${h.x}px, ${h.y}px)`, t.current(h);
    }, a = () => {
      i(null), n(null);
    }, f = G(u), m = nt(V(), a);
    return () => {
      f(), m();
    };
  }, [e, s]);
}, vn = () => {
  const { childNode: t, selecting: e } = _(), n = I(), o = I(), r = I(), [s, i] = mt(null), [l, c] = mt(null);
  St(ae, {
    boundary: s,
    setBoundary: i,
    expandingRef: n,
    movingRef: o,
    selectRef: r,
    move: l,
    setMove: c
  }), E(() => {
    r.current = document.createElement("div"), k(r.current, He), n.current = document.createElement("div"), k(n.current, $t), o.current = document.createElement("div");
  }, []);
  const { expanding: u } = dn();
  E(() => {
    if (e)
      return t.appendChild(r.current), () => {
        t.removeChild(r.current);
      };
  }, [e]), E(() => {
    if (!s)
      return;
    const a = {
      ...$t,
      transform: `translate(${s.left}px, ${s.top}px)`,
      width: ht(s.width),
      height: ht(s.height)
    }, f = k(o.current, a);
    return r.current.appendChild(o.current), () => {
      f(), r.current.removeChild(o.current);
    };
  }, [s]), E(() => {
    if (u && !s)
      return r.current.appendChild(n.current), () => {
        r.current.removeChild(n.current);
      };
  }, [u && !s]), gn();
}, En = ({ elementsRef: t }) => () => t.current, fe = ({
  id: t,
  elementsRef: e,
  position: n
}) => {
  const o = e.current[t];
  o && (o.node.current.style.transform = A({ position: n }), o.position = n);
}, yn = ({
  elementsRef: t,
  onElementsChangeRef: e
}) => (n, o) => {
  fe({
    id: n,
    elementsRef: t,
    position: o
  }), e.current && e.current({
    [n]: o
  });
}, xn = ({
  elementsRef: t
}) => (e, n) => {
  fe({
    id: e,
    elementsRef: t,
    position: n
  });
}, Cn = ({
  elementsRef: t,
  elementsUpdatePositionApiRef: e
}) => (n, o) => {
  if (!t.current[n])
    return null;
  const s = e.current[n];
  return s ? (s({
    [n]: o || {
      x: 0,
      y: 0
    }
  }), () => {
    const i = e.current[n];
    i && i(null);
  }) : null;
}, _t = (t) => ({
  ...t.current
}), bn = ({ childNode: t, positionRef: e, zoomRef: n }) => (o, r) => {
  const s = e;
  return s.current ? s.current = {
    x: e.current.x + o,
    y: e.current.y + r
  } : s.current = { x: o, y: r }, t.style.transform = A({
    position: e.current,
    zoom: n.current
  }), _t(e);
}, Mn = [
  "containerWidth",
  "containerHeight",
  "childWidth",
  "childHeight"
], Tn = (t, e = {}) => {
  if (typeof t == "number" || !Number.isNaN(parseInt(t, 10)))
    return t;
  const n = [], o = [];
  let r = "";
  const s = (l) => l.endsWith("px") ? parseInt(l.replace("px", ""), 10) : parseInt(l, 10), i = () => {
    Mn.includes(r) ? n.push(e[r]) : n.push(s(r)), r = "";
  };
  for (let l = 0; l < t.length; l++) {
    const c = t[l];
    switch (c) {
      case " ":
        break;
      case "+":
      case "-": {
        i(), o.push(c);
        break;
      }
      default:
        r += c;
        break;
    }
  }
  for (i(); o.length; ) {
    const l = o.shift(), c = n.shift() || 0, u = n.shift() || 0;
    l === "+" ? n.unshift(c + u) : l === "-" && n.unshift(c - u);
  }
  return n.pop();
}, wn = ({
  boundary: t,
  y: e,
  parentSize: n,
  childSize: o
}) => {
  const r = Math.max(o.height - n.height, 0);
  if (t.top === void 0 && t.bottom === void 0)
    return e;
  if (t.top !== void 0 && t.bottom === void 0)
    return Math.max(e, t.top - r);
  if (t.top === void 0 && t.bottom !== void 0)
    return Math.min(e, t.bottom - o.height + r);
  const s = t.top - r;
  if (e < s)
    return s;
  const i = t.bottom - o.height + r;
  return e > i ? i : e;
}, Rn = ({
  boundary: t,
  x: e,
  parentSize: n,
  childSize: o
}) => {
  const r = Math.max(o.width - n.width, 0);
  if (t.left === void 0 && t.right === void 0)
    return e;
  if (t.left !== void 0 && t.right === void 0)
    return Math.max(e, t.left - r);
  if (t.left === void 0 && t.right !== void 0)
    return Math.min(e, t.right - o.width + r);
  const s = t.left - r;
  if (e < s)
    return s;
  const i = t.right - o.width + r;
  return e > i ? i : e;
}, Sn = ({
  boundary: t,
  parentSize: e,
  childSize: n
}) => {
  if (!t)
    return {
      top: void 0,
      right: void 0,
      bottom: void 0,
      left: void 0
    };
  const o = {
    containerWidth: e.width,
    containerHeight: e.height,
    childWidth: n.width,
    childHeight: n.height
  }, r = {
    top: 0,
    left: 0,
    right: "containerWidth",
    bottom: "containerHeight"
  };
  return ["top", "left", "right", "bottom"].reduce((i, l) => {
    const c = t === !0 ? void 0 : t[l], u = Tn(
      c === void 0 ? r[l] : c,
      o
    );
    return {
      ...i,
      [l]: u
    };
  }, {});
}, yt = ({
  boundary: t,
  x: e,
  y: n,
  parentSize: o,
  childSize: r
}) => {
  const s = Sn({ boundary: t, parentSize: o, childSize: r }), i = {};
  return i.x = Rn({
    boundary: s,
    x: e,
    parentSize: o,
    childSize: r
  }), i.y = wn({
    boundary: s,
    y: n,
    parentSize: o,
    childSize: r
  }), i;
}, kt = ({ positionRef: t }) => () => _t(t), Ht = ({
  boundary: t,
  childNode: e,
  containerNode: n,
  positionRef: o,
  zoomRef: r
}) => (s, i) => {
  const l = v(n), c = yt({
    boundary: t,
    x: s,
    y: i,
    parentSize: l,
    childSize: v(e)
  }), u = o;
  u.current = c, e.style.transform = A({
    position: o.current,
    zoom: r.current
  });
}, Pn = ({ childNode: t, positionRef: e, zoomRef: n }) => () => {
  const o = n, r = e;
  o.current = 1, r.current = { x: 0, y: 0 }, t.style.transform = A({
    position: e.current,
    zoom: n.current
  });
}, de = (t) => Math.round(t * Ut) / Ut, It = ({ zoomRef: t }) => () => t.current, At = ({
  childNode: t,
  positionRef: e,
  zoomMax: n,
  zoomMin: o,
  zoomRef: r
}) => (s) => {
  const i = r;
  i.current = de(s), i.current < o ? i.current = o : i.current > n && (i.current = n), t.style.transform = A({
    position: e.current,
    zoom: r.current
  }), t.style.setProperty("--zoom", r.current.toString());
}, On = ({
  childNode: t,
  positionRef: e,
  zoomMax: n,
  zoomMin: o,
  zoomRef: r
}) => (s) => {
  At({
    childNode: t,
    positionRef: e,
    zoomMax: n,
    zoomMin: o,
    zoomRef: r
  })(It({ zoomRef: r })() + s);
}, zn = ({
  childNode: t,
  positionRef: e,
  zoomMax: n,
  zoomMin: o,
  zoomRef: r
}) => (s) => {
  At({
    childNode: t,
    positionRef: e,
    zoomMax: n,
    zoomMin: o,
    zoomRef: r
  })(It({ zoomRef: r })() - s);
}, Ln = () => {
  const {
    onContainerChangeRef: t,
    onContainerPositionChangeRef: e,
    onContainerZoomChangeRef: n,
    positionRef: o,
    zoomRef: r
  } = _(), s = ({ position: a, zoom: f }) => {
    const m = {
      position: _t(o),
      zoom: r.current
    };
    a && t.current && t.current(m), a && e.current && e.current(m), f && n.current && n.current(m);
  }, i = (a, f) => (...m) => {
    const d = a(...m);
    return s(f), d;
  };
  return {
    withEventAll: (a) => i(
      a,
      { position: !0, zoom: !0 }
    ),
    withEventPosition: (a) => i(
      a,
      { position: !0, zoom: !1 }
    ),
    withEventZoom: (a) => i(
      a,
      { position: !1, zoom: !0 }
    )
  };
}, _n = () => {
  const {
    apiRef: t,
    boundary: e,
    childNode: n,
    containerNode: o,
    onElementsChangeRef: r,
    positionRef: s,
    zoomMax: i,
    zoomMin: l,
    zoomRef: c
  } = _(), { elementsRef: u, elementsInMoveRef: a, elementsUpdatePositionApiRef: f } = W(), { withEventAll: m, withEventPosition: d, withEventZoom: h } = Ln();
  t.current = {
    childNode: n,
    move: d(
      bn({
        childNode: n,
        positionRef: s,
        zoomRef: c
      })
    ),
    getElements: En({ elementsRef: u }),
    getElementsInMove: () => a.current || {},
    grabElement: Cn({ elementsRef: u, elementsUpdatePositionApiRef: f }),
    goBackToBoundary: () => {
      const p = kt({ positionRef: s })();
      d(
        Ht({
          boundary: e,
          childNode: n,
          containerNode: o,
          positionRef: s,
          zoomRef: c
        })
      )(p.x, p.y);
    },
    updateElementPosition: yn({
      elementsRef: u,
      onElementsChangeRef: r
    }),
    updateElementPositionSilent: xn({
      elementsRef: u,
      onElementsChangeRef: r
    }),
    getPosition: kt({ positionRef: s }),
    setPosition: d(
      Ht({
        boundary: e,
        childNode: n,
        containerNode: o,
        positionRef: s,
        zoomRef: c
      })
    ),
    getZoom: It({ zoomRef: c }),
    setZoom: h(
      At({
        childNode: n,
        positionRef: s,
        zoomMax: i,
        zoomMin: l,
        zoomRef: c
      })
    ),
    zoomIn: h(
      On({
        childNode: n,
        positionRef: s,
        zoomMax: i,
        zoomMin: l,
        zoomRef: c
      })
    ),
    zoomOut: h(
      zn({
        childNode: n,
        positionRef: s,
        zoomMax: i,
        zoomMin: l,
        zoomRef: c
      })
    ),
    reset: m(
      Pn({
        childNode: n,
        positionRef: s,
        zoomRef: c
      })
    )
  };
}, In = () => {
  const {
    blockMovingRef: t,
    boundary: e,
    childNode: n,
    containerNode: o,
    className: r,
    disabled: s,
    disabledMove: i,
    onContextMenuRef: l,
    onContainerChangeRef: c,
    onContainerClickRef: u,
    onContainerPositionChangeRef: a,
    positionRef: f,
    zoomRef: m
  } = _(), d = le(), h = `${r}--grabbing`;
  E(() => {
    let p = null, g = null, y = null;
    const x = () => {
      document.body.style.userSelect = null, ee(document.body), X.remove(n, h), p = null;
    }, O = () => {
      g && (g(), g = null), y && (y(), y = null);
    }, M = () => {
      x(), O();
    }, C = (S) => {
      if (t.current)
        return;
      if (!p || S.buttons === 0) {
        M();
        return;
      }
      n.style.transition = null;
      const b = v(o), D = Y(S), J = yt({
        boundary: e,
        x: D.clientX - b.left - p.x,
        y: D.clientY - b.top - p.y,
        parentSize: b,
        childSize: v(n)
      });
      f.current = J, n.style.transform = A({
        position: f.current,
        zoom: m.current
      });
      const P = {
        position: { ...f.current },
        zoom: m.current
      };
      c.current && c.current(P), a.current && a.current(P);
    }, R = (S) => {
      if (S.button)
        return;
      const b = d(S), D = qt();
      u.current && u.current({
        e: S,
        x: b.x / m.current,
        y: b.y / m.current,
        stop: D
      }), !(s || i || D.done) && (document.body.style.userSelect = "none", X.add(n, h), p = b, O(), g = nt(o, M), y = G(C));
    }, T = (S) => {
      if (!l.current)
        return;
      const b = d(S);
      l.current({
        e: S,
        x: b.x / m.current,
        y: b.y / m.current
      });
    }, w = et(o, R), N = Gt(o, T);
    return () => {
      x(), O(), w(), N();
    };
  }, [e, s, i]);
}, An = () => {
  const {
    boundary: t,
    childNode: e,
    containerNode: n,
    disabledScrollHorizontal: o,
    disabledScrollVertical: r,
    onContainerChangeRef: s,
    onContainerPositionChangeRef: i,
    onElementsChangeRef: l,
    positionRef: c,
    scrollSpeed: u,
    zoomRef: a
  } = _(), { elementsRef: f, elementsInMoveRef: m } = W();
  E(() => {
    if (o && r)
      return;
    let d = 0;
    const h = (p) => {
      const g = (/* @__PURE__ */ new Date()).getTime();
      if (g - d < ze)
        return;
      d = g;
      const y = a.current, x = c.current, O = o ? 0 : u, M = r ? 0 : u, C = p.deltaY > 0, R = v(n), T = yt({
        boundary: t,
        x: C ? x.x - O : x.x + O,
        y: C ? x.y - M : x.y + M,
        parentSize: R,
        childSize: v(e)
      });
      c.current = T, e.style.transform = A({
        position: T,
        zoom: a.current
      });
      const w = {
        position: T,
        zoom: a.current
      };
      s.current && s.current(w), i.current && i.current(w);
      const N = {
        x: C ? x.x - T.x : T.x - x.x,
        y: C ? x.y - T.y : T.y - x.y
      }, S = m.current;
      S && Ot({
        elementsRef: f,
        elementsInMove: S,
        produceNextPosition: (b, D) => q({
          elementNode: D.node.current,
          childNode: e,
          x: D.position.x + (C ? N.x : -N.x) / y,
          y: D.position.y + (C ? N.y : -N.y) / y,
          zoom: a.current
        }),
        onElementsChange: l.current
      });
    };
    return n.addEventListener("wheel", h), () => {
      n.removeEventListener("wheel", h);
    };
  }, [JSON.stringify(t), o, r, u]);
}, Dn = ({
  e: t,
  isTouchEvent: e,
  zoomRef: n,
  zoomSpeed: o,
  zoomMin: r,
  zoomMax: s
}) => {
  const l = 1 + o * (e ? Ie : _e);
  return de(
    (() => {
      if (!t.deltaY)
        return n.current;
      if (t.deltaY < 0) {
        const u = n.current * l;
        return s && u >= s ? s : u;
      }
      const c = n.current / l;
      return r && c <= r ? r : c;
    })()
  );
}, Nn = 50, Zn = 2, me = (t, e, n, o) => {
  const r = Math.abs(t - n), s = Math.abs(e - o);
  return Math.sqrt(r * r + s * s);
}, Un = (t) => me(
  t.item(0).clientX,
  t.item(0).clientY,
  t.item(1).clientX,
  t.item(1).clientY
), Yn = (t) => {
  let e = 0, n = 0;
  for (let o = 0; o < t.length; o++)
    e += t.item(o).clientX, n += t.item(o).clientY;
  return e /= t.length, n /= t.length, [e, n];
}, $n = () => {
  let t = null, e = null, n = null, o = null;
  return [(i) => {
    if (i.touches.length !== Zn)
      return null;
    i.preventDefault(), i.stopPropagation();
    const [l, c] = Yn(i.touches);
    let u = null;
    e !== null && n !== null && (u = me(l, c, e, n));
    const a = Un(i.touches);
    return o || (o = setTimeout(() => {
      t = a, o = null, e = l, n = c;
    }, Nn)), u === null || Math.abs(
      a - t
    ) < u ? null : t === null || Math.round(a) === Math.round(t) ? {
      deltaY: 0,
      clientX: l,
      clientY: c,
      isTouchEvent: !0
    } : {
      deltaY: a > t ? -1 : 1,
      clientX: l,
      clientY: c,
      isTouchEvent: !0
    };
  }, () => {
    t = null, e = null, n = null, clearTimeout(o), o = null;
  }];
}, Wt = (t, e) => {
  let n = !1, o;
  const r = (...s) => {
    n || (t(...s), n = !0, o = setTimeout(() => {
      n = !1;
    }, e));
  };
  return r.cancel = () => {
    clearTimeout(o);
  }, r;
}, Bn = ({
  e: t,
  parentRect: e,
  zoomPosition: n
}) => {
  const o = {
    x: t.clientX - e.left,
    y: t.clientY - e.top
  };
  return n && (n.x === "center" ? o.x = e.width / 2 : n.x !== void 0 && (o.x = n.x), n.y === "center" ? o.y = e.height / 2 : n.y !== void 0 && (o.y = n.y)), o;
}, Xn = () => {
  const {
    blockMovingRef: t,
    boundary: e,
    childNode: n,
    containerNode: o,
    disabled: r,
    disabledZoom: s,
    positionRef: i,
    onContainerChangeRef: l,
    onContainerZoomChangeRef: c,
    zoomInitial: u,
    zoomMax: a,
    zoomMin: f,
    zoomPosition: m,
    zoomRef: d,
    zoomSpeed: h
  } = _(), p = [
    JSON.stringify(e),
    r,
    s,
    u,
    h,
    a,
    f,
    m == null ? void 0 : m.x,
    m == null ? void 0 : m.y
  ];
  return E(() => {
    if (r || s)
      return;
    const [g, y] = $n();
    let x = null;
    const O = (w) => {
      const N = v(n), S = v(o);
      w.isTouchEvent && (clearTimeout(x), x = setTimeout(() => {
        t.current = !1;
      }, Ye), t.current = !0);
      const b = Bn({
        e: w,
        parentRect: S,
        zoomPosition: m
      }), D = (b.x - i.current.x) / d.current, J = (b.y - i.current.y) / d.current, P = Dn({
        e: w,
        isTouchEvent: w.isTouchEvent,
        zoomRef: d,
        zoomSpeed: h,
        zoomMin: f,
        zoomMax: a
      }), ot = d.current;
      d.current = P;
      const Q = yt({
        boundary: e,
        x: b.x - D * P,
        y: b.y - J * P,
        parentSize: S,
        childSize: {
          width: N.width * (P / ot),
          height: N.height * (P / ot)
        }
      });
      i.current = Q, n.style.transform = A({ position: Q, zoom: P }), n.style.setProperty("--zoom", P.toString()), l.current && l.current({ position: { ...i.current }, zoom: P }), c.current && c.current({ zoom: P, position: { ...i.current } });
    }, M = Wt(O, Ze), C = Wt(O, Ue), R = (w) => {
      w.preventDefault(), M(w);
    }, T = (w) => {
      Kt(w) && C(g(w));
    };
    return o.addEventListener("touchstart", T), o.addEventListener("touchmove", T), o.addEventListener("touchup", y), o.addEventListener("touchend", y), o.addEventListener("touchcancel", y), o.addEventListener("wheel", R), () => {
      o.removeEventListener("touchstart", T), o.removeEventListener("touchmove", T), o.removeEventListener("touchup", y), o.removeEventListener("touchend", y), o.removeEventListener("touchcancel", y), C.cancel(), o.removeEventListener("wheel", R), M.cancel();
    };
  }, p), d;
}, kn = () => {
  const {
    childNode: t,
    className: e = Te,
    containerNode: n,
    disabledUserSelect: o,
    height: r,
    positionRef: s,
    selecting: i,
    width: l,
    zoomRef: c
  } = _();
  In(), Xn(), _n(), An(), E(() => {
    const u = {
      ...Be,
      height: ht(r),
      width: ht(l),
      transform: A({
        position: s.current,
        zoom: c.current
      }),
      "--zoom": c.current.toString()
    };
    return k(t, u);
  }, [l, r]), E(() => {
    t.setAttribute("draggable", "false");
    const u = k(n, $e);
    return () => {
      t.removeAttribute("draggable"), u();
    };
  }, []), E(() => {
    if (i)
      return t.style.pointerEvents = "all", () => {
        t.style.pointerEvents = null;
      };
  }, [i]), E(() => {
    if (!e)
      return;
    const u = B(t, `${e}__in`), a = B(n, e);
    return () => {
      u(), a();
    };
  }, [e]), E(() => {
    if (!(!e || !i))
      return B(n, `${e}--selecting`);
  }, [e, i]), E(() => {
    if (!o)
      return;
    const u = B(n, `${e}--disabled-user-select`), a = k(t, Xe);
    return () => {
      u(), a();
    };
  }, [e, o]);
};
let Vt = 1;
const Wn = (t, e = {}) => {
  const n = xe(Vt), o = n(Fe, Ge);
  o.context.props = je(t, e);
  const r = fn(n), s = n(Me), i = n(kn), l = n(vn), c = () => Ce([
    o,
    s,
    i,
    ...r.queue,
    l
  ]), u = (m) => {
    o.updateProps(m) && c();
  }, a = () => {
    r.unmount(), s.unmount(), l.unmount(), i.unmount(), o.unmount();
  };
  c();
  const f = o.context.props.apiRef;
  return Vt++, {
    addElement: r.add,
    destroy: a,
    setOptions: u,
    ...f.current
  };
};
export {
  Wn as default,
  Ke as getAllowedProps
};
