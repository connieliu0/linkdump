import q, { createContext as Et, useRef as _, useEffect as Mt, useState as Ct, useImperativeHandle as wt, useMemo as St, forwardRef as Qe, useLayoutEffect as Pe, useContext as Pt } from "react";
const Z = (e) => ({ current: e }), ge = {
  EFFECT: "effect",
  REF: "ref",
  STATE: "state"
};
let Ge = null;
const fe = [], It = () => fe[fe.length - 1], At = (e, t) => {
  fe.push(e), Ge = t;
}, Tt = () => fe.pop(), $t = () => Ge, D = {
  get: It,
  getInitializationId: $t,
  push: At,
  pop: Tt
}, Wt = (e, t, n) => {
  const o = {
    batchTimeoutRender: null,
    it: 0,
    hooks: [],
    render: () => {
      o.unmounted || (D.push(o, e), o.it = 0, t(o.props), D.pop());
    },
    props: {},
    unmounted: !1
  }, r = () => {
    o.unmounted || (o.unmounted = !0, o.hooks.forEach((s) => {
      s.type === ge.EFFECT && s.onUnmount && s.onUnmount();
    }));
  }, i = (s) => {
    const l = n ? n(s) : s;
    let c = !1;
    return Object.entries(l).forEach(([u, d]) => {
      if (d === void 0)
        return;
      const a = o.props[u];
      a && typeof a == "object" && "current" in a ? a.current = d : (o.props[u] = d, c = !0);
    }), c;
  };
  return {
    context: o,
    render: o.render,
    unmount: r,
    updateProps: i
  };
}, Ot = (e = 0) => (t, n) => Wt(e, t, n), Yt = (e) => {
  e.forEach((t) => {
    t.render();
  });
}, kt = (e, t) => {
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}, R = (e, t) => {
  const n = D.get(), o = n.it;
  n.it++;
  let r = n.hooks[o];
  if (!r) {
    const s = e();
    r = { type: ge.EFFECT, deps: t, onUnmount: s }, n.hooks[o] = r;
    return;
  }
  if (kt(r.deps, t))
    return;
  r.onUnmount && r.onUnmount();
  const i = e();
  r.onUnmount = i, r.deps = t;
}, we = {}, Ie = (e, t) => {
  R(() => {
    const n = `${D.getInitializationId()}.${e}`;
    return we[n] = t, () => {
      delete we[n];
    };
  }, [t]);
}, Ae = (e) => we[`${D.getInitializationId()}.${e}`], W = (e) => {
  const t = D.get(), n = t.it;
  t.it++;
  let o = t.hooks[n];
  if (!o) {
    const r = { current: e || null };
    return o = { type: ge.REF, value: r }, t.hooks[n] = o, r;
  }
  return o.value;
}, pe = (e) => {
  const t = D.get(), n = t.it;
  t.it++;
  let o = t.hooks[n];
  const r = (i) => {
    o.value = i, clearTimeout(t.batchTimeoutRender), t.batchTimeoutRender = setTimeout(t.render, 0);
  };
  return o ? [o.value, r] : (o = { type: ge.STATE, value: e }, t.hooks[n] = o, [e, r]);
}, Ke = "elements", j = () => Ae(Ke), Zt = () => {
  const e = W({}), t = W(null), n = W({}), o = W();
  Ie(Ke, {
    elementsRef: e,
    elementsInMoveRef: t,
    elementsUpdatePositionApiRef: n,
    lastElementMouseMoveEventRef: o
  });
}, V = 30, Lt = "panzoom-core", Xt = "panzoom-core-element", Ht = 20, ae = 15, Ut = 15, Bt = 15, Dt = 250, jt = 20, Ft = 30, Jt = 0.125, Vt = 0.04, qt = 0.3, _t = 5, Qt = 1, Ue = 1e4, Gt = 20, Be = 1, Kt = 5, en = 300, tn = {
  width: "100%",
  height: "100%",
  overflow: "hidden",
  "touch-action": "none",
  "-webkit-font-smoothing": "antialiased"
}, nn = {
  position: "relative",
  overflow: "hidden",
  "transform-origin": "0 0",
  "pointer-events": "none"
}, on = {
  "user-select": "none"
}, rn = {
  display: "inline-block",
  position: "absolute",
  left: "0px",
  top: "0px",
  "pointer-events": "all"
}, sn = {
  position: "absolute",
  width: "100%",
  height: "100%",
  left: "0px",
  top: "0px",
  "z-index": "2147483647"
}, De = {
  "background-color": "#ccc",
  opacity: "0.5"
}, cn = (e, t) => {
  var n, o;
  document.body.classList.add(t), (o = (n = e == null ? void 0 : e.parentNode) == null ? void 0 : n.classList) == null || o.add(`${t}-in`);
}, ln = (e, t) => {
  var n, o;
  document.body.classList.remove(t), document.body.getAttribute("class") || document.body.removeAttribute("class"), (o = (n = e == null ? void 0 : e.parentNode) == null ? void 0 : n.classList) == null || o.remove(`${t}-in`);
}, U = {
  add: cn,
  remove: ln
}, F = () => window, et = (e) => "touches" in e ? e.touches.length > 1 : !1, Q = (e, t, n) => (t.forEach((o) => {
  e.addEventListener(o, n);
}), () => {
  t.forEach((o) => {
    e.removeEventListener(o, n);
  });
}), oe = (e, t) => Q(e, ["mousedown", "touchstart"], t), re = (e, t) => {
  const n = Q(F(), ["mouseup"], t), o = Q(e, ["touchend", "touchcancel"], t);
  return () => {
    n(), o();
  };
}, G = (e) => {
  const t = Q(F(), ["mousemove"], e), n = (r) => {
    et(r) || e(r);
  }, o = Q(F(), ["touchmove"], n);
  return () => {
    t(), o();
  };
}, tt = (e, t) => Q(e, ["contextmenu"], t), L = (e) => {
  const { touches: t } = e;
  if (t)
    return {
      clientX: t[0].clientX,
      clientY: t[0].clientY
    };
  const n = e;
  return {
    clientX: n.clientX,
    clientY: n.clientY
  };
}, O = ({ position: e, zoom: t }) => t ? `translate(${e.x}px, ${e.y}px) scale(${t})` : `translate(${e.x}px, ${e.y}px)`, nt = () => {
  const e = () => {
    e.done = !0;
  };
  return e.done = !1, e;
}, Te = ({
  elementsRef: e,
  elementsInMove: t,
  onElementsChange: n,
  produceNextPosition: o
}) => {
  const r = {}, i = () => {
    let c = null;
    const u = (d, a) => {
      c !== null && Math.abs(d - a) >= Math.abs(c) || (c = d - a, u.value = c);
    };
    return u.value = c, u;
  }, s = i(), l = i();
  Object.entries(t).forEach(([c, u]) => {
    const d = e.current[c], a = o(u, d);
    s(d.position.x, a.x), l(d.position.y, a.y);
  }), Object.entries(t).forEach(([c]) => {
    const u = e.current[c], d = {
      x: u.position.x - s.value,
      y: u.position.y - l.value
    };
    r[c] = d, u.position = d, u.node.current.style.transform = O({ position: d });
  }), n && n(r);
}, z = (e) => e.getBoundingClientRect(), xe = (e) => {
  const t = (n, o) => {
    for (let r = e; r && !(!r || o && o(r)); r = r.parentNode)
      n(r);
  };
  return {
    forEachToWindow: (n) => {
      t(n);
    },
    forEach: (n) => {
      t(n, (o) => o === document.body);
    }
  };
}, ze = (e) => {
  const t = e.parentNode, n = {
    x: 0,
    y: 0
  };
  return xe(t.parentNode).forEachToWindow((o) => {
    n.x += o.scrollLeft || 0, n.y += o.scrollTop || 0;
  }), n;
}, K = ({
  elementNode: e,
  childNode: t,
  x: n,
  y: o,
  zoom: r
}) => {
  const i = z(e), s = z(t), l = (s.width - i.width) / r, c = (s.height - i.height) / r, u = { x: n, y: o };
  return u.x < 0 ? u.x = 0 : u.x > l && (u.x = l), u.y < 0 ? u.y = 0 : u.y > c && (u.y = c), u;
}, ot = "panzoom", T = () => Ae(ot), un = (e) => {
  Ie(ot, e);
}, dn = (e, t) => {
  const n = e.parentNode;
  return {
    apiRef: Z(null),
    blockMovingRef: Z(!1),
    boundary: t.boundary,
    childNode: e,
    className: t.className || "panzoom-core",
    containerNode: n,
    disabled: t.disabled || !1,
    disabledElements: t.disabledElements || !1,
    disabledScrollHorizontal: t.disabledScrollHorizontal === void 0 ? !0 : t.disabledScrollHorizontal,
    disabledScrollVertical: t.disabledScrollVertical === void 0 ? !0 : t.disabledScrollVertical,
    disabledUserSelect: t.disabledUserSelect || !1,
    disabledZoom: t.disabledZoom || !1,
    disabledMove: t.disabledMove || !1,
    elementsAutoMoveAtEdge: t.elementsAutoMoveAtEdge === void 0 ? !0 : t.elementsAutoMoveAtEdge,
    onContextMenuRef: Z(t.onContextMenu),
    onContainerChangeRef: Z(t.onContainerChange),
    onContainerClickRef: Z(t.onContainerClick),
    onContainerPositionChangeRef: Z(t.onContainerPositionChange),
    onContainerZoomChangeRef: Z(t.onContainerZoomChange),
    onElementsChangeRef: Z(t.onElementsChange),
    positionRef: Z({ x: 0, y: 0 }),
    selecting: t.selecting || !1,
    scrollSpeed: t.scrollSpeed || Ft,
    width: t.width || "100%",
    height: t.height || "100%",
    zoomRef: Z(t.zoomInitial || Be),
    zoomInitial: t.zoomInitial || Be,
    zoomMin: t.zoomMin || qt,
    zoomMax: t.zoomMax || _t,
    zoomPosition: t.zoomPosition,
    zoomSpeed: t.zoomSpeed || Qt
  };
}, $e = () => [
  "boundary",
  "className",
  "disabled",
  "disabledElements",
  "disabledMove",
  "disabledScrollHorizontal",
  "disabledScrollVertical",
  "disabledUserSelect",
  "disabledZoom",
  "elementsAutoMoveAtEdge",
  "onElementsChange",
  "onContextMenu",
  "onContainerChange",
  "onContainerClick",
  "onContainerPositionChange",
  "onContainerZoomChange",
  "selecting",
  "scrollSpeed",
  "width",
  "height",
  "zoomInitial",
  "zoomMax",
  "zoomMin",
  "zoomPosition",
  "zoomSpeed"
], an = (e) => {
  const t = {}, n = $e();
  return Object.entries(e).forEach(([o, r]) => {
    !n.includes(o) || r === void 0 || (typeof r == "function" ? t[`${o}Ref`] = r : t[o] = r);
  }), t;
}, rt = () => {
  const { childNode: e, containerNode: t, zoomRef: n } = T();
  return (o, r) => {
    const i = L(o), s = z(t), l = z(r), c = ze(e);
    return {
      x: (i.clientX - l.left + s.left + c.x) / n.current,
      y: (i.clientY - l.top + s.top + c.y) / n.current
    };
  };
}, it = () => {
  const { childNode: e, positionRef: t, zoomRef: n } = T();
  return (o, r, i) => {
    const s = L(o), l = ze(e);
    return K({
      elementNode: i,
      childNode: e,
      x: (s.clientX - t.current.x + l.x) / n.current - r.x,
      y: (s.clientY - t.current.y + l.y) / n.current - r.y,
      zoom: n.current
    });
  };
}, H = (e, t) => {
  const n = t.trim().split(" ").filter((o) => o);
  return n.forEach((o) => {
    e.classList.add(o);
  }), () => {
    n.forEach((o) => {
      e.classList.remove(o);
    }), e.className || e.removeAttribute("class");
  };
}, st = (e) => {
  e.getAttribute("style") || e.removeAttribute("style");
}, B = (e, t) => (Object.entries(t).forEach(([n, o]) => {
  e.style.setProperty(n, o);
}), () => {
  Object.entries(t).forEach(([n]) => {
    e.style.removeProperty(n);
  }), st(e);
});
let je = 2;
const ct = (e) => {
  je += 1, e.style.zIndex = je.toString();
}, We = () => {
  const e = z(document.body), t = F();
  return !e.width || !e.height ? {
    width: t.innerWidth,
    height: t.innerHeight
  } : {
    width: Math.min(e.width, t.innerWidth),
    height: Math.min(e.height, t.innerHeight)
  };
}, Re = (e) => {
  const t = z(e.parentNode), n = We(), o = [
    n.width - (t.left < 0 ? 0 : t.left),
    t.right
  ], r = [
    n.height - (t.top < 0 ? 0 : t.top),
    t.bottom
  ];
  xe(e.parentNode).forEach((l) => {
    if (!l.getBoundingClientRect)
      return;
    const c = z(l);
    c.right > 0 && o.push(c.right - c.left), c.bottom > 0 && r.push(c.bottom - c.top);
  });
  let i = Math.min(...o), s = Math.min(...r);
  return i < 0 && (i = 0), s < 0 && (s = 0), [i, s];
}, lt = (e) => {
  const [t] = Re(e), n = z(e), o = z(e.parentNode), r = Math.max(o.left, 0);
  return n.right - t - r;
}, mn = (e, t) => {
  const n = z(e), o = z(e.parentNode), r = t.current.x + n.width;
  return r + o.left > 0 && r >= 0 && lt(e) <= 0;
}, ut = (e) => {
  const [, t] = Re(e), n = z(e), o = z(e.parentNode), r = Math.max(o.top, 0);
  return n.bottom - t - r;
}, hn = (e, t) => {
  const n = z(e), o = z(e.parentNode), r = t.current.y + n.height;
  return r + o.top > 0 && r >= 0 && ut(e) <= 0;
}, fn = (e, t) => {
  const n = ze(e), o = z(e.parentNode), [r] = Re(e);
  return t.current.x + o.left >= 0 && t.current.x >= 0 && t.current.x < r + n.x;
}, pn = (e, t) => {
  const n = ze(e), o = z(e.parentNode), [, r] = Re(e);
  return t.current.y + o.top >= 0 && t.current.y >= 0 && t.current.y < r + n.y;
}, me = {
  left: fn,
  right: mn,
  top: pn,
  bottom: hn
}, yn = (e) => e.clientHeight < e.scrollHeight, dt = (e) => "scrollX" in e && "scrollY" in e, Se = (e) => {
  if (dt(e)) {
    const n = e;
    return {
      x: n.scrollX || 0,
      y: n.scrollY || 0
    };
  }
  const t = e;
  return {
    x: t.scrollLeft || 0,
    y: t.scrollTop || 0
  };
}, Fe = (e, t) => {
  if (dt(e))
    e.scrollBy(t.x, t.y);
  else {
    const n = e;
    n.scrollLeft += t.x, n.scrollTop += t.y;
  }
  return Se(e);
}, gn = (e, t, n) => {
  const o = e.parentNode, r = z(o), i = We(), s = t < 0 && r.right > 0 && i.width > r.right, l = t > 0 && r.left >= 0, c = s || l, u = n < 0 && r.bottom > 0 && i.height > r.bottom, d = n > 0 && r.top >= 0, a = u || d, f = {
    x: t,
    y: n
  };
  return c && a || xe(o.parentNode).forEachToWindow((m) => {
    if (yn(m)) {
      if (!c) {
        let h = Se(m);
        const p = h.x;
        h = Fe(m, { x: -f.x, y: 0 }), f.x += h.x - p;
      }
      if (!a) {
        let h = Se(m);
        const p = h.y;
        h = Fe(m, { x: 0, y: -f.y }), f.y += h.y - p;
      }
    }
  }), f;
}, xn = ({
  childNode: e,
  positionRef: t,
  addPosition: n,
  zoomRef: o
}) => {
  const r = gn(e, n.x, n.y);
  if (t.current = {
    x: t.current.x + r.x,
    y: t.current.y + r.y
  }, r.y < 0) {
    const i = ut(e);
    i < -r.y && (t.current.y += -r.y - i);
  } else
    r.y > 0 && t.current.y > 0 && (t.current.y = 0);
  if (r.x < 0) {
    const i = lt(e);
    i < -r.x && (t.current.x += -r.x - i);
  } else
    r.x > 0 && t.current.x > 0 && (t.current.x = 0);
  e.style.transform = O({
    position: t.current,
    zoom: o.current
  });
}, zn = (e, t) => {
  const n = z(e), o = z(e.parentNode), r = o.left > 0 ? o.left : 0, i = o.top > 0 ? o.top : 0, s = We();
  let l = n.left - r;
  l < 0 && (l = 0);
  let c = n.top - i;
  c < 0 && (c = 0);
  const u = [
    s.width - r,
    n.right,
    o.right - V,
    o.right - o.left
  ], d = [
    s.height - i,
    n.bottom,
    o.bottom - V,
    o.bottom - o.top
  ];
  xe(e.parentNode).forEach((y) => {
    if (!y.getBoundingClientRect)
      return;
    const g = z(y);
    g.right > 0 && u.push(g.right - r), g.bottom > 0 && d.push(g.bottom - i);
  });
  const a = Math.min(...u), f = Math.min(...d), m = t.clientX - r, h = t.clientY - i, p = {
    top: !1,
    bottom: !1,
    left: !1,
    right: !1
  };
  return l + V > m ? p.left = !0 : m + V > a && (p.right = !0), c + V > h ? p.top = !0 : h + V > f && (p.bottom = !0), p;
}, Rn = () => {
  const {
    childNode: e,
    onElementsChangeRef: t,
    positionRef: n,
    zoomRef: o
  } = T(), { elementsRef: r, lastElementMouseMoveEventRef: i } = j();
  return (s) => {
    const l = setInterval(() => {
      if (!i.current || !e)
        return;
      const c = {
        x: 0,
        y: 0
      }, u = zn(e, i.current);
      u.left && !me.left(e, n) ? c.x = ae : u.right && !me.right(e, n) && (c.x = -ae), u.top && !me.top(e, n) ? c.y = ae : u.bottom && !me.bottom(e, n) && (c.y = -ae), !(!c.x && !c.y) && (xn({
        childNode: e,
        positionRef: n,
        addPosition: c,
        zoomRef: o
      }), Te({
        elementsRef: r,
        elementsInMove: s,
        produceNextPosition: (d, a) => K({
          elementNode: a.node.current,
          childNode: e,
          x: a.position.x - c.x / o.current,
          y: a.position.y - c.y / o.current,
          zoom: o.current
        }),
        onElementsChange: t.current
      }));
    }, Ht);
    return () => {
      clearInterval(l), i.current = null;
    };
  };
}, at = (e) => `${e}px`, mt = ({
  className: e,
  elementNode: t,
  cb: n,
  onAfterResize: o,
  resizerNode: r
}) => {
  oe(r, (i) => {
    if (i.button)
      return;
    i.preventDefault(), i.stopPropagation();
    const s = H(t, `${e}--resizing`), l = n(i);
    let c = null;
    c = re(r, () => {
      s(), l(), c(), o();
    }), ct(t);
  });
}, ht = () => {
  const e = document.createElement("div");
  return e.style.position = "absolute", e;
}, vn = ({
  childNode: e,
  className: t,
  elementNode: n,
  elementsRef: o,
  id: r,
  onAfterResize: i,
  onStartResizing: s,
  resizedMaxWidth: l,
  resizedMinWidth: c,
  resizerWidth: u,
  zoomRef: d
}) => {
  const a = ht();
  return a.style.left = "0px", a.style.top = "0px", a.style.width = at(u), a.style.height = "100%", a.style.cursor = "w-resize", mt({
    className: t,
    elementNode: n,
    resizerNode: a,
    cb: (f) => {
      const m = L(f), h = e.getBoundingClientRect(), p = F().getComputedStyle(n), y = new DOMMatrixReadOnly(p.transform), g = n.getBoundingClientRect();
      let x = (g.right - h.left) / d.current;
      return l && l < x && (x = l), s(), G((w) => {
        const N = L(w), v = {
          x: N.clientX - m.clientX,
          y: N.clientY - m.clientY
        };
        let E = g.width / d.current - v.x / d.current;
        c && E < c && (v.x += (E - c) * d.current, E = c), E > x && (v.x += (E - x) * d.current, E = x), n.style.width = `${E}px`;
        const b = K({
          elementNode: n,
          childNode: e,
          x: y.e + v.x / d.current,
          y: y.f,
          zoom: d.current
        });
        c && E < c && (b.x = y.e + g.width / d.current - c), n.style.transform = O({ position: b }), o.current[r].position = b;
      });
    },
    onAfterResize: i
  }), n.appendChild(a), () => {
    n.removeChild(a);
  };
}, bn = ({
  childNode: e,
  className: t,
  elementNode: n,
  elementsRef: o,
  id: r,
  onAfterResize: i,
  onStartResizing: s,
  resizedMaxWidth: l,
  resizedMinWidth: c,
  resizerWidth: u,
  zoomRef: d
}) => {
  const a = ht();
  return a.style.right = "0px", a.style.top = "0px", a.style.width = at(u), a.style.height = "100%", a.style.cursor = "e-resize", mt({
    className: t,
    elementNode: n,
    resizerNode: a,
    cb: (f) => {
      const m = L(f), h = n.getBoundingClientRect(), p = e.getBoundingClientRect();
      let y = (p.right - h.left) / d.current;
      return l && l < y && (y = l), s(), G((g) => {
        const x = L(g), w = {
          x: x.clientX - m.clientX,
          y: x.clientY - m.clientY
        };
        let N = h.width / d.current + w.x / d.current;
        if (c && N < c) {
          n.style.width = `${c}px`;
          return;
        }
        N > y && (N = y), n.style.width = `${N}px`;
        const v = K({
          elementNode: n,
          childNode: e,
          x: (h.x - p.x) / d.current,
          y: (h.y - p.y) / d.current,
          zoom: d.current
        });
        n.style.transform = O({ position: v }), o.current[r].position = v;
      });
    },
    onAfterResize: i
  }), n.appendChild(a), () => {
    n.removeChild(a);
  };
}, Nn = (e, t) => {
  const { childNode: n, className: o, zoomRef: r } = T(), { elementsRef: i } = j(), s = `${o}--element-resizing`, l = W();
  l.current = t.onAfterResize;
  const c = W();
  c.current = t.onStartResizing, R(() => {
    if (t.disabled || !t.resizable)
      return;
    const u = t.resizedMinWidth || Bt, d = t.resizerWidth || Ut, a = () => {
      U.add(n, s), c.current && c.current({
        id: t.id
      });
    }, f = () => {
      U.remove(n, s), l.current && l.current({
        id: t.id
      });
    }, m = vn({
      childNode: n,
      elementNode: e,
      elementsRef: i,
      ...t,
      onAfterResize: f,
      onStartResizing: a,
      resizedMinWidth: u,
      resizerWidth: d,
      zoomRef: r
    }), h = bn({
      childNode: n,
      elementNode: e,
      elementsRef: i,
      ...t,
      onAfterResize: f,
      onStartResizing: a,
      resizedMinWidth: u,
      resizerWidth: d,
      zoomRef: r
    });
    return () => {
      m(), h();
    };
  }, [
    s,
    t.className,
    t.disabled,
    t.resizable,
    t.resizedMaxWidth,
    t.resizedMinWidth,
    t.resizerWidth
  ]);
}, En = (e) => ({
  id: t,
  className: n = Xt,
  disabled: o,
  disabledMove: r,
  draggableSelector: i,
  followers: s = [],
  x: l = 0,
  y: c = 0,
  family: u,
  height: d,
  onAfterResize: a,
  onContextMenu: f,
  onStartResizing: m,
  onClick: h,
  onMouseUp: p,
  resizable: y,
  resizerWidth: g,
  resizedMaxWidth: x,
  resizedMinWidth: w,
  width: N
}) => {
  if (!t)
    throw new Error("'id' prop for element can't be undefined");
  const v = rt(), E = it(), b = Rn(), [M, $] = pe(null), { elementsInMoveRef: S } = j(), C = (I) => {
    $(I), S.current = I;
  };
  Nn(e, {
    className: n,
    disabled: o,
    id: t,
    onAfterResize: a,
    onStartResizing: m,
    resizable: y,
    resizerWidth: g,
    resizedMaxWidth: x,
    resizedMinWidth: w
  });
  const {
    blockMovingRef: Y,
    boundary: ee,
    childNode: P,
    className: ie,
    disabledElements: te,
    elementsAutoMoveAtEdge: Le,
    onElementsChangeRef: Xe
  } = T(), se = `${ie}--element-moving`, {
    elementsRef: J,
    elementsUpdatePositionApiRef: He,
    lastElementMouseMoveEventRef: Nt
  } = j(), be = W();
  be.current = h;
  const Ne = W();
  Ne.current = p;
  const Ee = W();
  Ee.current = f, R(() => (He.current[t] = C, () => {
    e.style.transform = null, e.style.zIndex = null, delete J.current[t], delete He.current[t];
  }), []), R(() => {
    const I = { x: l, y: c };
    e.style.transform = O({ position: I }), J.current[t] = {
      family: u,
      id: t,
      node: { current: e },
      position: I
    };
  }, [t, l, c]), R(() => {
    const I = J.current[t];
    I && (I.family = u);
  }, [u]), R(() => {
    if (o || te)
      return;
    const I = (A) => i && !A.target.closest(i), ce = (A) => {
      if (A.button || I(A))
        return;
      const ne = v(A, e), ue = nt();
      if (be.current && be.current({
        id: t,
        family: u,
        e: A,
        stop: ue,
        ...ne
      }), A.preventDefault(), A.stopPropagation(), ue.done || r)
        return;
      const k = Object.values(J.current).filter(
        (X) => X.id === t || u && X.family === u || s.includes(X.id)
      );
      C(k.reduce((X, de) => (X[de.id] = v(A, de.node.current), X), {})), ct(e);
    }, le = (A) => {
      if (!Ee.current || I(A))
        return;
      const ne = v(A, e);
      Ee.current({
        id: t,
        family: u,
        e: A,
        ...ne
      });
    }, Me = oe(e, ce), Ce = tt(e, le);
    return () => {
      Me(), Ce();
    };
  }, [
    o,
    te,
    r,
    i,
    u,
    JSON.stringify(s),
    JSON.stringify(ee),
    t,
    se
  ]), R(() => {
    if (!M)
      return;
    U.add(P, se);
    let I = null;
    Le && (I = b(M));
    let ce = {};
    const le = (k) => {
      ce = k, Xe.current && Xe.current(k);
    }, Me = (k) => {
      if (Y.current || k.buttons === 0) {
        C(null);
        return;
      }
      Nt.current = L(k), Te({
        elementsRef: J,
        elementsInMove: M,
        produceNextPosition: (X, de) => E(k, X, de.node.current),
        onElementsChange: le
      });
    }, Ce = (k) => {
      Ne.current && Ne.current({
        id: t,
        family: u,
        e: k,
        ...J.current[t].position
      }), C(null), U.remove(P, se);
    }, A = setInterval(() => {
      le(ce);
    }, Dt), ne = re(e, Ce), ue = G(Me);
    return () => {
      I && I(), ne(), ue(), clearInterval(A), U.remove(P, se);
    };
  }, [Le, M]), R(
    () => B(e, rn),
    []
  ), R(
    () => H(e, `${n} ${n}--id-${t}`),
    [n, t]
  ), R(() => {
    if (o)
      return H(e, `${n}--disabled`);
  }, [n, o]), R(() => {
    e.style.width = N === void 0 ? null : `${N}px`;
  }, [N]), R(() => {
    e.style.height = d === void 0 ? null : `${d}px`;
  }, [d]);
}, Mn = (e) => {
  const t = [];
  return {
    add: (n, o) => {
      const r = En(n), i = e(r);
      return i.updateProps(o), t.push(i), i.render(), {
        destroy: () => {
          i.unmount();
          const s = t.findIndex((l) => l === i);
          s < 0 || t.splice(s, 1);
        },
        setOptions: (s) => {
          i.updateProps(s), i.render();
        }
      };
    },
    queue: t,
    unmount: () => {
      t.forEach((n) => {
        n.unmount();
      });
    }
  };
}, ye = (e) => typeof e == "number" ? `${e}px` : e, ft = () => {
  const { containerNode: e, positionRef: t } = T();
  return (n) => {
    const o = L(n), r = z(e);
    return {
      x: o.clientX - r.left - (t.current.x || 0),
      y: o.clientY - r.top - (t.current.y || 0)
    };
  };
}, pt = "select", Oe = () => Ae(pt), Cn = () => {
  const [e, t] = pe(null), {
    boundary: n,
    setBoundary: o,
    selectRef: r,
    expandingRef: i
  } = Oe(), s = W(), { childNode: l, selecting: c, zoomRef: u } = T(), d = ft(), a = (f, m) => {
    const h = z(l), p = d(f);
    p.x < 0 ? p.x = 0 : p.x > h.width && (p.x = h.width), p.y < 0 ? p.y = 0 : p.y > h.height && (p.y = h.height);
    const y = {
      width: (p.x - m.x) / u.current,
      height: (p.y - m.y) / u.current,
      left: m.x / u.current,
      top: m.y / u.current
    };
    y.width < 0 && (y.width = -y.width, y.left -= y.width), y.height < 0 && (y.height = -y.height, y.top -= y.height), y.right = y.left + y.width, y.bottom = y.top + y.height, i.current.style.transform = `translate(${y.left}px, ${y.top}px)`, i.current.style.width = `${y.width}px`, i.current.style.height = `${y.height}px`, s.current = y;
  };
  return R(() => {
    if (e || n || !c)
      return;
    const f = (m) => {
      m.preventDefault(), m.stopPropagation();
      const h = d(m);
      t(h), a(m, h);
    };
    return r.current.addEventListener("mousedown", f), () => {
      r.current.removeEventListener("mousedown", f);
    };
  }, [n, e, c]), R(() => {
    if (!e || n)
      return;
    const f = (p) => {
      a(p, e), t(null), o(s.current);
    }, m = G((p) => a(p, e)), h = re(F(), f);
    return () => {
      m(), h();
    };
  }, [n, e]), { expanding: e, boundary: n };
}, he = (e) => typeof e == "string" ? parseInt(e, 10) : e, wn = (e, t) => {
  const n = {};
  return Object.entries(t).forEach(([o, r]) => {
    r.position.x >= he(e.left) && r.position.x <= he(e.right) && r.position.y >= he(e.top) && r.position.y <= he(e.bottom) && (n[o] = r);
  }), n;
}, Sn = (e) => {
  const t = {};
  return Object.entries(e).forEach(([n, o]) => {
    t[n] = { ...o.position };
  }), t;
}, Pn = () => {
  const { boundary: e } = Oe(), { childNode: t, onElementsChangeRef: n, zoomRef: o } = T(), { elementsRef: r } = j(), i = W();
  return R(() => {
    if (!e)
      return;
    const s = wn(e, r.current), l = Sn(s);
    let c = null;
    return i.current = (u) => {
      c || (c = u);
      const d = {};
      Object.entries(s).forEach(([a, f]) => {
        const m = l[a], { node: h } = f, p = K({
          elementNode: f.node.current,
          childNode: t,
          x: m.x + (u.x - c.x),
          y: m.y + (u.y - c.y),
          zoom: o.current
        });
        r.current[f.id].position = p, d[a] = p, h.current.style.transform = `translate(${p.x}px, ${p.y}px)`;
      }), n.current && n.current(d);
    }, () => {
      i.current = null;
    };
  }, [e]), i;
}, In = () => {
  const e = Pn(), {
    boundary: t,
    setBoundary: n,
    movingRef: o,
    selectRef: r,
    move: i,
    setMove: s
  } = Oe(), l = rt(), c = it();
  R(() => {
    if (!t)
      return;
    const u = (m) => {
      m.preventDefault(), m.stopPropagation(), n(null);
    }, d = (m) => {
      m.preventDefault(), m.stopPropagation();
      const h = l(m, r.current), p = {
        x: h.x - t.left,
        y: h.y - t.top
      };
      s(p);
    }, a = oe(r.current, u), f = oe(o.current, d);
    return () => {
      a(), f();
    };
  }, [t]), R(() => {
    if (!i)
      return;
    const u = (m) => {
      m.preventDefault(), m.stopPropagation();
      const h = c(m, i, o.current);
      o.current.style.transform = `translate(${h.x}px, ${h.y}px)`, e.current(h);
    }, d = () => {
      s(null), n(null);
    }, a = G(u), f = re(F(), d);
    return () => {
      a(), f();
    };
  }, [t, i]);
}, An = () => {
  const { childNode: e, selecting: t } = T(), n = W(), o = W(), r = W(), [i, s] = pe(null), [l, c] = pe(null);
  Ie(pt, {
    boundary: i,
    setBoundary: s,
    expandingRef: n,
    movingRef: o,
    selectRef: r,
    move: l,
    setMove: c
  }), R(() => {
    r.current = document.createElement("div"), B(r.current, sn), n.current = document.createElement("div"), B(n.current, De), o.current = document.createElement("div");
  }, []);
  const { expanding: u } = Cn();
  R(() => {
    if (t)
      return e.appendChild(r.current), () => {
        e.removeChild(r.current);
      };
  }, [t]), R(() => {
    if (!i)
      return;
    const d = {
      ...De,
      transform: `translate(${i.left}px, ${i.top}px)`,
      width: ye(i.width),
      height: ye(i.height)
    }, a = B(o.current, d);
    return r.current.appendChild(o.current), () => {
      a(), r.current.removeChild(o.current);
    };
  }, [i]), R(() => {
    if (u && !i)
      return r.current.appendChild(n.current), () => {
        r.current.removeChild(n.current);
      };
  }, [u && !i]), In();
}, Tn = ({ elementsRef: e }) => () => e.current, yt = ({
  id: e,
  elementsRef: t,
  position: n
}) => {
  const o = t.current[e];
  o && (o.node.current.style.transform = O({ position: n }), o.position = n);
}, $n = ({
  elementsRef: e,
  onElementsChangeRef: t
}) => (n, o) => {
  yt({
    id: n,
    elementsRef: e,
    position: o
  }), t.current && t.current({
    [n]: o
  });
}, Wn = ({
  elementsRef: e
}) => (t, n) => {
  yt({
    id: t,
    elementsRef: e,
    position: n
  });
}, On = ({
  elementsRef: e,
  elementsUpdatePositionApiRef: t
}) => (n, o) => {
  if (!e.current[n])
    return null;
  const r = t.current[n];
  return r ? (r({
    [n]: o || {
      x: 0,
      y: 0
    }
  }), () => {
    const i = t.current[n];
    i && i(null);
  }) : null;
}, Ye = (e) => ({
  ...e.current
}), Yn = ({ childNode: e, positionRef: t, zoomRef: n }) => (o, r) => {
  const i = t;
  return i.current ? i.current = {
    x: t.current.x + o,
    y: t.current.y + r
  } : i.current = { x: o, y: r }, e.style.transform = O({
    position: t.current,
    zoom: n.current
  }), Ye(t);
}, kn = [
  "containerWidth",
  "containerHeight",
  "childWidth",
  "childHeight"
], Zn = (e, t = {}) => {
  if (typeof e == "number" || !Number.isNaN(parseInt(e, 10)))
    return e;
  const n = [], o = [];
  let r = "";
  const i = (l) => l.endsWith("px") ? parseInt(l.replace("px", ""), 10) : parseInt(l, 10), s = () => {
    kn.includes(r) ? n.push(t[r]) : n.push(i(r)), r = "";
  };
  for (let l = 0; l < e.length; l++) {
    const c = e[l];
    switch (c) {
      case " ":
        break;
      case "+":
      case "-": {
        s(), o.push(c);
        break;
      }
      default:
        r += c;
        break;
    }
  }
  for (s(); o.length; ) {
    const l = o.shift(), c = n.shift() || 0, u = n.shift() || 0;
    l === "+" ? n.unshift(c + u) : l === "-" && n.unshift(c - u);
  }
  return n.pop();
}, Ln = ({
  boundary: e,
  y: t,
  parentSize: n,
  childSize: o
}) => {
  const r = Math.max(o.height - n.height, 0);
  if (e.top === void 0 && e.bottom === void 0)
    return t;
  if (e.top !== void 0 && e.bottom === void 0)
    return Math.max(t, e.top - r);
  if (e.top === void 0 && e.bottom !== void 0)
    return Math.min(t, e.bottom - o.height + r);
  const i = e.top - r;
  if (t < i)
    return i;
  const s = e.bottom - o.height + r;
  return t > s ? s : t;
}, Xn = ({
  boundary: e,
  x: t,
  parentSize: n,
  childSize: o
}) => {
  const r = Math.max(o.width - n.width, 0);
  if (e.left === void 0 && e.right === void 0)
    return t;
  if (e.left !== void 0 && e.right === void 0)
    return Math.max(t, e.left - r);
  if (e.left === void 0 && e.right !== void 0)
    return Math.min(t, e.right - o.width + r);
  const i = e.left - r;
  if (t < i)
    return i;
  const s = e.right - o.width + r;
  return t > s ? s : t;
}, Hn = ({
  boundary: e,
  parentSize: t,
  childSize: n
}) => {
  if (!e)
    return {
      top: void 0,
      right: void 0,
      bottom: void 0,
      left: void 0
    };
  const o = {
    containerWidth: t.width,
    containerHeight: t.height,
    childWidth: n.width,
    childHeight: n.height
  }, r = {
    top: 0,
    left: 0,
    right: "containerWidth",
    bottom: "containerHeight"
  };
  return ["top", "left", "right", "bottom"].reduce((i, s) => {
    const l = e === !0 ? void 0 : e[s], c = Zn(
      l === void 0 ? r[s] : l,
      o
    );
    return {
      ...i,
      [s]: c
    };
  }, {});
}, ve = ({
  boundary: e,
  x: t,
  y: n,
  parentSize: o,
  childSize: r
}) => {
  const i = Hn({ boundary: e, parentSize: o, childSize: r }), s = {};
  return s.x = Xn({
    boundary: i,
    x: t,
    parentSize: o,
    childSize: r
  }), s.y = Ln({
    boundary: i,
    y: n,
    parentSize: o,
    childSize: r
  }), s;
}, Je = ({ positionRef: e }) => () => Ye(e), Ve = ({
  boundary: e,
  childNode: t,
  containerNode: n,
  positionRef: o,
  zoomRef: r
}) => (i, s) => {
  const l = z(n), c = ve({
    boundary: e,
    x: i,
    y: s,
    parentSize: l,
    childSize: z(t)
  }), u = o;
  u.current = c, t.style.transform = O({
    position: o.current,
    zoom: r.current
  });
}, Un = ({ childNode: e, positionRef: t, zoomRef: n }) => () => {
  const o = n, r = t;
  o.current = 1, r.current = { x: 0, y: 0 }, e.style.transform = O({
    position: t.current,
    zoom: n.current
  });
}, gt = (e) => Math.round(e * Ue) / Ue, ke = ({ zoomRef: e }) => () => e.current, Ze = ({
  childNode: e,
  positionRef: t,
  zoomMax: n,
  zoomMin: o,
  zoomRef: r
}) => (i) => {
  const s = r;
  s.current = gt(i), s.current < o ? s.current = o : s.current > n && (s.current = n), e.style.transform = O({
    position: t.current,
    zoom: r.current
  }), e.style.setProperty("--zoom", r.current.toString());
}, Bn = ({
  childNode: e,
  positionRef: t,
  zoomMax: n,
  zoomMin: o,
  zoomRef: r
}) => (i) => {
  Ze({
    childNode: e,
    positionRef: t,
    zoomMax: n,
    zoomMin: o,
    zoomRef: r
  })(ke({ zoomRef: r })() + i);
}, Dn = ({
  childNode: e,
  positionRef: t,
  zoomMax: n,
  zoomMin: o,
  zoomRef: r
}) => (i) => {
  Ze({
    childNode: e,
    positionRef: t,
    zoomMax: n,
    zoomMin: o,
    zoomRef: r
  })(ke({ zoomRef: r })() - i);
}, jn = () => {
  const {
    onContainerChangeRef: e,
    onContainerPositionChangeRef: t,
    onContainerZoomChangeRef: n,
    positionRef: o,
    zoomRef: r
  } = T(), i = ({ position: l, zoom: c }) => {
    const u = {
      position: Ye(o),
      zoom: r.current
    };
    l && e.current && e.current(u), l && t.current && t.current(u), c && n.current && n.current(u);
  }, s = (l, c) => (...u) => {
    const d = l(...u);
    return i(c), d;
  };
  return {
    withEventAll: (l) => s(
      l,
      { position: !0, zoom: !0 }
    ),
    withEventPosition: (l) => s(
      l,
      { position: !0, zoom: !1 }
    ),
    withEventZoom: (l) => s(
      l,
      { position: !1, zoom: !0 }
    )
  };
}, Fn = () => {
  const {
    apiRef: e,
    boundary: t,
    childNode: n,
    containerNode: o,
    onElementsChangeRef: r,
    positionRef: i,
    zoomMax: s,
    zoomMin: l,
    zoomRef: c
  } = T(), { elementsRef: u, elementsInMoveRef: d, elementsUpdatePositionApiRef: a } = j(), { withEventAll: f, withEventPosition: m, withEventZoom: h } = jn();
  e.current = {
    childNode: n,
    move: m(
      Yn({
        childNode: n,
        positionRef: i,
        zoomRef: c
      })
    ),
    getElements: Tn({ elementsRef: u }),
    getElementsInMove: () => d.current || {},
    grabElement: On({ elementsRef: u, elementsUpdatePositionApiRef: a }),
    goBackToBoundary: () => {
      const p = Je({ positionRef: i })();
      m(
        Ve({
          boundary: t,
          childNode: n,
          containerNode: o,
          positionRef: i,
          zoomRef: c
        })
      )(p.x, p.y);
    },
    updateElementPosition: $n({
      elementsRef: u,
      onElementsChangeRef: r
    }),
    updateElementPositionSilent: Wn({
      elementsRef: u,
      onElementsChangeRef: r
    }),
    getPosition: Je({ positionRef: i }),
    setPosition: m(
      Ve({
        boundary: t,
        childNode: n,
        containerNode: o,
        positionRef: i,
        zoomRef: c
      })
    ),
    getZoom: ke({ zoomRef: c }),
    setZoom: h(
      Ze({
        childNode: n,
        positionRef: i,
        zoomMax: s,
        zoomMin: l,
        zoomRef: c
      })
    ),
    zoomIn: h(
      Bn({
        childNode: n,
        positionRef: i,
        zoomMax: s,
        zoomMin: l,
        zoomRef: c
      })
    ),
    zoomOut: h(
      Dn({
        childNode: n,
        positionRef: i,
        zoomMax: s,
        zoomMin: l,
        zoomRef: c
      })
    ),
    reset: f(
      Un({
        childNode: n,
        positionRef: i,
        zoomRef: c
      })
    )
  };
}, Jn = () => {
  const {
    blockMovingRef: e,
    boundary: t,
    childNode: n,
    containerNode: o,
    className: r,
    disabled: i,
    disabledMove: s,
    onContextMenuRef: l,
    onContainerChangeRef: c,
    onContainerClickRef: u,
    onContainerPositionChangeRef: d,
    positionRef: a,
    zoomRef: f
  } = T(), m = ft(), h = `${r}--grabbing`;
  R(() => {
    let p = null, y = null, g = null;
    const x = () => {
      document.body.style.userSelect = null, st(document.body), U.remove(n, h), p = null;
    }, w = () => {
      y && (y(), y = null), g && (g(), g = null);
    }, N = () => {
      x(), w();
    }, v = (S) => {
      if (e.current)
        return;
      if (!p || S.buttons === 0) {
        N();
        return;
      }
      n.style.transition = null;
      const C = z(o), Y = L(S), ee = ve({
        boundary: t,
        x: Y.clientX - C.left - p.x,
        y: Y.clientY - C.top - p.y,
        parentSize: C,
        childSize: z(n)
      });
      a.current = ee, n.style.transform = O({
        position: a.current,
        zoom: f.current
      });
      const P = {
        position: { ...a.current },
        zoom: f.current
      };
      c.current && c.current(P), d.current && d.current(P);
    }, E = (S) => {
      if (S.button)
        return;
      const C = m(S), Y = nt();
      u.current && u.current({
        e: S,
        x: C.x / f.current,
        y: C.y / f.current,
        stop: Y
      }), !(i || s || Y.done) && (document.body.style.userSelect = "none", U.add(n, h), p = C, w(), y = re(o, N), g = G(v));
    }, b = (S) => {
      if (!l.current)
        return;
      const C = m(S);
      l.current({
        e: S,
        x: C.x / f.current,
        y: C.y / f.current
      });
    }, M = oe(o, E), $ = tt(o, b);
    return () => {
      x(), w(), M(), $();
    };
  }, [t, i, s]);
}, Vn = () => {
  const {
    boundary: e,
    childNode: t,
    containerNode: n,
    disabledScrollHorizontal: o,
    disabledScrollVertical: r,
    onContainerChangeRef: i,
    onContainerPositionChangeRef: s,
    onElementsChangeRef: l,
    positionRef: c,
    scrollSpeed: u,
    zoomRef: d
  } = T(), { elementsRef: a, elementsInMoveRef: f } = j();
  R(() => {
    if (o && r)
      return;
    let m = 0;
    const h = (p) => {
      const y = (/* @__PURE__ */ new Date()).getTime();
      if (y - m < jt)
        return;
      m = y;
      const g = d.current, x = c.current, w = o ? 0 : u, N = r ? 0 : u, v = p.deltaY > 0, E = z(n), b = ve({
        boundary: e,
        x: v ? x.x - w : x.x + w,
        y: v ? x.y - N : x.y + N,
        parentSize: E,
        childSize: z(t)
      });
      c.current = b, t.style.transform = O({
        position: b,
        zoom: d.current
      });
      const M = {
        position: b,
        zoom: d.current
      };
      i.current && i.current(M), s.current && s.current(M);
      const $ = {
        x: v ? x.x - b.x : b.x - x.x,
        y: v ? x.y - b.y : b.y - x.y
      }, S = f.current;
      S && Te({
        elementsRef: a,
        elementsInMove: S,
        produceNextPosition: (C, Y) => K({
          elementNode: Y.node.current,
          childNode: t,
          x: Y.position.x + (v ? $.x : -$.x) / g,
          y: Y.position.y + (v ? $.y : -$.y) / g,
          zoom: d.current
        }),
        onElementsChange: l.current
      });
    };
    return n.addEventListener("wheel", h), () => {
      n.removeEventListener("wheel", h);
    };
  }, [JSON.stringify(e), o, r, u]);
}, qn = ({
  e,
  isTouchEvent: t,
  zoomRef: n,
  zoomSpeed: o,
  zoomMin: r,
  zoomMax: i
}) => {
  const s = 1 + o * (t ? Vt : Jt);
  return gt(
    (() => {
      if (!e.deltaY)
        return n.current;
      if (e.deltaY < 0) {
        const c = n.current * s;
        return i && c >= i ? i : c;
      }
      const l = n.current / s;
      return r && l <= r ? r : l;
    })()
  );
}, _n = 50, Qn = 2, xt = (e, t, n, o) => {
  const r = Math.abs(e - n), i = Math.abs(t - o);
  return Math.sqrt(r * r + i * i);
}, Gn = (e) => xt(
  e.item(0).clientX,
  e.item(0).clientY,
  e.item(1).clientX,
  e.item(1).clientY
), Kn = (e) => {
  let t = 0, n = 0;
  for (let o = 0; o < e.length; o++)
    t += e.item(o).clientX, n += e.item(o).clientY;
  return t /= e.length, n /= e.length, [t, n];
}, eo = () => {
  let e = null, t = null, n = null, o = null;
  return [(r) => {
    if (r.touches.length !== Qn)
      return null;
    r.preventDefault(), r.stopPropagation();
    const [i, s] = Kn(r.touches);
    let l = null;
    t !== null && n !== null && (l = xt(i, s, t, n));
    const c = Gn(r.touches);
    return o || (o = setTimeout(() => {
      e = c, o = null, t = i, n = s;
    }, _n)), l === null || Math.abs(
      c - e
    ) < l ? null : e === null || Math.round(c) === Math.round(e) ? {
      deltaY: 0,
      clientX: i,
      clientY: s,
      isTouchEvent: !0
    } : {
      deltaY: c > e ? -1 : 1,
      clientX: i,
      clientY: s,
      isTouchEvent: !0
    };
  }, () => {
    e = null, t = null, n = null, clearTimeout(o), o = null;
  }];
}, qe = (e, t) => {
  let n = !1, o;
  const r = (...i) => {
    n || (e(...i), n = !0, o = setTimeout(() => {
      n = !1;
    }, t));
  };
  return r.cancel = () => {
    clearTimeout(o);
  }, r;
}, to = ({
  e,
  parentRect: t,
  zoomPosition: n
}) => {
  const o = {
    x: e.clientX - t.left,
    y: e.clientY - t.top
  };
  return n && (n.x === "center" ? o.x = t.width / 2 : n.x !== void 0 && (o.x = n.x), n.y === "center" ? o.y = t.height / 2 : n.y !== void 0 && (o.y = n.y)), o;
}, no = () => {
  const {
    blockMovingRef: e,
    boundary: t,
    childNode: n,
    containerNode: o,
    disabled: r,
    disabledZoom: i,
    positionRef: s,
    onContainerChangeRef: l,
    onContainerZoomChangeRef: c,
    zoomInitial: u,
    zoomMax: d,
    zoomMin: a,
    zoomPosition: f,
    zoomRef: m,
    zoomSpeed: h
  } = T(), p = [
    JSON.stringify(t),
    r,
    i,
    u,
    h,
    d,
    a,
    f == null ? void 0 : f.x,
    f == null ? void 0 : f.y
  ];
  return R(() => {
    if (r || i)
      return;
    const [y, g] = eo();
    let x = null;
    const w = (M) => {
      const $ = z(n), S = z(o);
      M.isTouchEvent && (clearTimeout(x), x = setTimeout(() => {
        e.current = !1;
      }, en), e.current = !0);
      const C = to({
        e: M,
        parentRect: S,
        zoomPosition: f
      }), Y = (C.x - s.current.x) / m.current, ee = (C.y - s.current.y) / m.current, P = qn({
        e: M,
        isTouchEvent: M.isTouchEvent,
        zoomRef: m,
        zoomSpeed: h,
        zoomMin: a,
        zoomMax: d
      }), ie = m.current;
      m.current = P;
      const te = ve({
        boundary: t,
        x: C.x - Y * P,
        y: C.y - ee * P,
        parentSize: S,
        childSize: {
          width: $.width * (P / ie),
          height: $.height * (P / ie)
        }
      });
      s.current = te, n.style.transform = O({ position: te, zoom: P }), n.style.setProperty("--zoom", P.toString()), l.current && l.current({ position: { ...s.current }, zoom: P }), c.current && c.current({ zoom: P, position: { ...s.current } });
    }, N = qe(w, Gt), v = qe(w, Kt), E = (M) => {
      M.preventDefault(), N(M);
    }, b = (M) => {
      et(M) && v(y(M));
    };
    return o.addEventListener("touchstart", b), o.addEventListener("touchmove", b), o.addEventListener("touchup", g), o.addEventListener("touchend", g), o.addEventListener("touchcancel", g), o.addEventListener("wheel", E), () => {
      o.removeEventListener("touchstart", b), o.removeEventListener("touchmove", b), o.removeEventListener("touchup", g), o.removeEventListener("touchend", g), o.removeEventListener("touchcancel", g), v.cancel(), o.removeEventListener("wheel", E), N.cancel();
    };
  }, p), m;
}, oo = () => {
  const {
    childNode: e,
    className: t = Lt,
    containerNode: n,
    disabledUserSelect: o,
    height: r,
    positionRef: i,
    selecting: s,
    width: l,
    zoomRef: c
  } = T();
  Jn(), no(), Fn(), Vn(), R(() => {
    const u = {
      ...nn,
      height: ye(r),
      width: ye(l),
      transform: O({
        position: i.current,
        zoom: c.current
      }),
      "--zoom": c.current.toString()
    };
    return B(e, u);
  }, [l, r]), R(() => {
    e.setAttribute("draggable", "false");
    const u = B(n, tn);
    return () => {
      e.removeAttribute("draggable"), u();
    };
  }, []), R(() => {
    if (s)
      return e.style.pointerEvents = "all", () => {
        e.style.pointerEvents = null;
      };
  }, [s]), R(() => {
    if (!t)
      return;
    const u = H(e, `${t}__in`), d = H(n, t);
    return () => {
      u(), d();
    };
  }, [t]), R(() => {
    if (!(!t || !s))
      return H(n, `${t}--selecting`);
  }, [t, s]), R(() => {
    if (!o)
      return;
    const u = H(n, `${t}--disabled-user-select`), d = B(e, on);
    return () => {
      u(), d();
    };
  }, [t, o]);
};
let _e = 1;
const zt = (e, t = {}) => {
  const n = Ot(_e), o = n(un, an);
  o.context.props = dn(e, t);
  const r = Mn(n), i = n(Zt), s = n(oo), l = n(An), c = () => Yt([
    o,
    i,
    s,
    ...r.queue,
    l
  ]), u = (f) => {
    o.updateProps(f) && c();
  }, d = () => {
    r.unmount(), i.unmount(), l.unmount(), s.unmount(), o.unmount();
  };
  c();
  const a = o.context.props.apiRef;
  return _e++, {
    addElement: r.add,
    destroy: d,
    setOptions: u,
    ...a.current
  };
}, Rt = Et({}), vt = (e, t) => {
  const n = _(!1);
  Mt(() => {
    if (!n.current) {
      n.current = !0;
      return;
    }
    return e();
  }, t);
}, bt = ({
  allowedProps: e,
  apiRef: t,
  children: n,
  props: o
}) => {
  const r = _(), i = _(), s = _(null), [l, c] = Ct(!1), u = e.map((f) => o[f]);
  vt(() => {
    s.current && s.current.setOptions(o);
  }, u), wt(
    l ? t : void 0,
    () => s.current,
    [l]
  );
  const d = St(() => ({
    initialized: l,
    panZoomRef: s
  }), [l]), a = /* @__PURE__ */ q.createElement(Rt.Provider, { value: d }, /* @__PURE__ */ q.createElement("div", { ref: i }, /* @__PURE__ */ q.createElement("div", { ref: r }, n)));
  return {
    childRef: r,
    parentRef: i,
    panZoomRef: s,
    render: a,
    setInitialized: c
  };
}, ro = $e(), io = ({
  apiRef: e,
  children: t,
  ...n
}) => {
  const {
    childRef: o,
    panZoomRef: r,
    render: i,
    setInitialized: s
  } = bt({
    allowedProps: ro,
    apiRef: e,
    children: t,
    props: n
  });
  return Pe(() => (r.current = zt(o.current, {
    ...n,
    className: n.className || "react-panzoom"
  }), r.current.setOptions(n), s(!0), r.current.destroy), []), i;
}, so = Qe((e, t) => /* @__PURE__ */ q.createElement(io, { ...e, apiRef: t }));
so.displayName = "PanZoom";
const ho = ({
  children: e,
  className: t,
  disabled: n,
  disabledMove: o,
  draggableSelector: r,
  family: i,
  followers: s,
  height: l,
  id: c,
  onAfterResize: u,
  onClick: d,
  onContextMenu: a,
  onMouseUp: f,
  onStartResizing: m,
  resizable: h,
  resizedMaxWidth: p,
  resizedMinWidth: y,
  resizerWidth: g,
  width: x,
  x: w,
  y: N
}) => {
  const v = _(), E = _(), { initialized: b, panZoomRef: M } = Pt(Rt), $ = {
    className: t || "react-panzoom-element",
    id: c,
    disabled: n,
    disabledMove: o,
    draggableSelector: r,
    family: i,
    followers: s,
    height: l,
    onAfterResize: u,
    onClick: d,
    onContextMenu: a,
    onMouseUp: f,
    onStartResizing: m,
    resizable: h,
    resizedMaxWidth: p,
    resizedMinWidth: y,
    resizerWidth: g,
    width: x,
    x: w,
    y: N
  };
  return Pe(() => {
    if (b)
      return E.current = M.current.addElement(v.current, $), E.current.destroy;
  }, [b]), vt(() => {
    !b || !E.current || E.current.setOptions($);
  }, [
    n,
    o,
    r,
    i,
    b,
    JSON.stringify(s),
    l,
    c,
    u,
    d,
    a,
    f,
    m,
    h,
    p,
    y,
    g,
    x,
    w,
    N
  ]), /* @__PURE__ */ q.createElement("div", { ref: v }, e);
}, co = ["boundary"], lo = $e().filter((e) => !co.includes(e)), uo = ({
  apiRef: e,
  children: t,
  cover: n,
  onCoverLoad: o,
  ...r
}) => {
  const {
    childRef: i,
    parentRef: s,
    panZoomRef: l,
    render: c,
    setInitialized: u
  } = bt({
    apiRef: e,
    allowedProps: lo,
    children: t,
    props: r
  });
  return Pe(() => {
    u(!1);
    const d = new Image();
    d.src = n;
    let a = !1;
    const f = () => {
      if (a)
        return;
      a = !0;
      const y = s.current.parentNode.getBoundingClientRect(), g = {
        width: d.naturalWidth,
        height: d.naturalHeight
      }, x = Math.max(
        y.width / g.width,
        y.height / g.height
      );
      i.current.style.backgroundImage = `url('${n}')`, l.current = zt(
        i.current,
        {
          ...r,
          boundary: !0,
          className: r.className || "react-panzoom-with-cover",
          width: g.width,
          height: g.height,
          zoomInitial: x,
          zoomMin: x,
          zoomMax: r.zoomMax * x
        }
      ), e && "current" in e && (e.current = l.current), u(!0), o && o();
    }, m = setInterval(() => {
      d.naturalWidth > 0 && d.naturalHeight > 0 && (f(), clearInterval(m));
    }, 100), h = () => {
      f(), clearInterval(m);
    };
    return d.addEventListener("load", h), () => {
      clearInterval(m), d.removeEventListener("load", h), l.current && (l.current.destroy(), l.current = null);
    };
  }, [n]), c;
}, ao = Qe(
  (e, t) => /* @__PURE__ */ q.createElement(uo, { ...e, apiRef: t })
);
ao.displayName = "PanZoomWithCover";
export {
  ho as Element,
  ao as PanZoomWithCover,
  so as default
};
